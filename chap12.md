# 表示层抉择

回去看看我们将函数作为值的那个解释器，你能找到其中不一致的地方吗？

__思考题__
> 找到了吗？

考虑一下我们是怎么表示这两种值的：数和函数。忽略其外面`numV`和`closV`这一层，注意它们底层的数据表示。我们使用Racket中的数来表示要解释的语言中的数，但是我们没有使用Racket中的函数（闭包）来表示要解释的语言中的函数（闭包）。

这就是不一致的地方。都使用或者都不使用Racket中的值表示目标语言中对应值的表示会显得更一致一点。那么我们为什么要做出当前这种决定呢？

We were trying to illustrate and point, and that point is what we will explore right now.

## 12.1 改变表示

我们首先花一段时间探索一下数。Racket中数被实现的极为强大使得其非常利于重用：它支持任意大小的整数（bignums）、有理数（受益于整数的bignum表示），复数等等。因此它能表示出大部分常规语言中的数系统。然而，这并不意味着它就一定符合我们的需求：它可能还是过于简单或者过于复杂：

1. 如果我们需要的是受限的数系统，它就显得过于复杂。例如Java中规定了一组定长（fixed-size）的数的表示（如：int被指定为32位的）。超出这些规定范围的数在Java中将不能直接被表示，同时算术运算也要考虑到能表示数的范围（例如：由于溢出，1加2147483647将不能得到2147483648）。
2. 如果我们需要更为丰富的数系统，它又会捉襟见肘，比如包含四元数或者关联概念的数。

糟糕的是，我们根本没有想过自己的需求，就直接轻率的使用Racket中的数作为我们语言中数的表示。

之所以这样做，是因为我们并不关心数本身；我们关心的是诸如将函数作为值这样的编程语言特性。然而，作为语言设计者，你应当在最开始的时候就考虑到这些问题。

现在我们来讨论一下闭包的表示。可以通过发掘Racket中闭包的概念用于表示目标语言中的闭包，与之对应的，使用Racket中的函数调用来实现目标语言中的函数调用。

__思考题__
> 使用Racket函数替换之前闭包的实现。

现在实现它：

```Racket
(define-type Value
  [numV (n : number)]
  [closV (f : (Value -> Value))])

(define (interp [expr : ExprC] [env : Env]) : Value
  (type-case ExprC expr
    [numC (n) (numV n)]
    [idC (n) (lookup n env)]
    [appC (f a) (local ([define f-value (interp f env)]
                        [define a-value (interp a env)])
                  ((closV-f f-value) a-value))]
    [plusC (l r) (num+ (interp l env) (interp r env))]
    [multC (l r) (num* (interp l env) (interp r env))]
    [lamC (a b) (closV (lambda (arg-val)
                         (interp b
                                 (extend-env (bind a arg-val)
                                             env))))]))
```

__练习__
> 注意到一个有趣的改变。之前的实现中，环境是在解释appC时被扩展的。这里它是在lamC的解释过程中被展开的。是这两个中有一个出错了吗？如果不是的话，为什么会出现这种情况？

这种实现方式显然更为简洁，但是我们失去了一项重要的东西：对我们要实现的概念（这里是闭包）的理解。告诉别人源语言中的函数对应于lambda等于什么都没说：如果我们已经知道lambda是干嘛的我们可能就不会花时间去学它；如果不知道的话，这种直接映射的实现方式也不能教会我们新的知识（而且很可能会让本来就对该概念一无所知的我们更加混乱）。处于同样的理由，我们没有使用Racket中的状态去理解各种状态操作符【注释】。

然而一旦我们理解了某个特性，使用该种表示将不再是个问题。这样做会使得我们的解释器更为简洁，毕竟我们不打算自行实现所有事情。事实上，如果没有事先深度探索这些特性的表示，后面的一些解释器【注释】会显得毫无可读性可言。尽管如此，我们还是应该注意防范过度使用宿主语言的特性可能招致的风险。

> 【注释】有点像是，“现在我们已经能够通过加一来理解加法，我们可以用加法来定义乘法：不再需要使用加一来定义乘法”

## 12.2 错误

当程序出错时，程序员需要谨慎展示的错误信息。使用宿主语言特性处理错误可能使程序员看见宿主语言中抛出的错误，这些错误将不被他们所理解。因此，我们需要谨慎的将各种情况的错误翻译成我们语言的用户所能理解的术语，且不让宿主语言中的错误信息“泄漏过来”。

更糟糕的情形是，那些本应出错的程序可能不会报错！例如，我们设计时决定让函数只出现再顶层，如果我们没有很好的检测这点，其被去语法糖后得到lambda，最后可能在解释器中正确解释得到一个结果，而它本来应该使解释器出错停止。因此，我们应该极其注意，**仅允许期望的表层语言被映射到宿主语言中**。

再举一个例子，考虑赋值操作，在我们的语言中，给一个未绑定的变量赋值会产生一个错误。但是在有些语言中，这种操作会导致该变量被定义。语言设计者常犯的一个错误是没有很好的确定一个特定的语义，然后推脱说“它就是实现出来的那个样子”。这种态度（a）是懒惰、马虎的，（b）可能招致一些不可预料、负面的后果，（c）它使得将语言从一个实现平台移到另一个实现平台变得非常困难。不要犯这个错误！

## 12.3 改变含义

将作为值的函数映射为lambda之所以可行是因为我们本来就希望它们**拥有相同的含义**。但是这种实现方式使得改变函数的含义变得极为困难。让我给你设想一个情形：假设我们想要实现动态作用域。在我们原来的解释器中，这很简单（我们之前这样做过，极其简单）。试着在使用了lambda的解释器中实现动态作用域。同样的，将及早求值（eager evaluation）特性映射到一个惰性求值（lazy application）的语言中也是挺有难度的，或者说至少不太容易【注释】。

> 【注释】请别让它超出假想阶段。

__练习__
> 将上面的解释器改成动态作用域的。

使用自己构造的数据结构作为语言的特性的表示并不会使事情更为简单，但一般来说也不会使事情变得更为复杂；与之相对映射成语言本身特性的方式会使一些特性——通常是宿主语言中已有的特性——的实现极为简单，但是使其他特性的实现变得比较困难。还有一个风险是，我们可能并不十分清楚宿主语言的某个特性具体实现了些什么（比如，“lambda”是否真的实现了静态作用域？）

[TODO:]
The moral is that this is a good property to exploit only we want to “pass through” the base language’s meaning—-and then it is especially wise because it ensures that we don’t accidentally change its meaning. If, however, we want to exploit a significant part of the base language and only augment its meaning, perhaps other implementation strategies [REF] will work just as well instead of writing an interpreter.

## 12.4 另一个例子

我们再考虑改变一个特性表示方式。还记得环境是什么吗？

环境是一个名字到值（如果有赋值的话，那么是名字到地址）的映射。我们通过自建的数据结构实现了映射，但是我们可以通过其他方式实现映射吗？当然可以，使用函数就行！这样，环境就变成了一个接收名字为参数返回其绑定值的函数（或者返回一个错误）：

> `(define-type-alias Env (symbol -> Value))`

空的环境是什么？一个对于任何名字的查询都抛出错误的函数：

> ```Racket
> (define (mt-env [name : symbol])
>   (error 'lookup "name not found"))
> ```

（原则上我们可以给它的返回值添加类型注解，应该是Value，但是在这里没啥意义）。给环境添加一个新的绑定即创建一个新的函数，该函数中检查该名字是不是正在扩展的那个绑定，如果是，直接放回对应的绑定值，如果不是，在被扩展的环境中查询该名字的绑定值。

> ```Racket
> (define (extend-env [b : Binding] [e : Env])
>   (lambda ([name : symbol]) : Value
>     (if (symbol=? name (bind-name b))
>       (bind-val b)
>       (lookup name e))))
> ```

最后，怎么再环境中查询绑定值呢？传入要查询的名字**调用**该环境即可。

> ```Racket
> (define (lookup [n : symbol] [e : Env]) : Value
>   (e n))
> ```

到这里我们就完成环境的表示的改变。
