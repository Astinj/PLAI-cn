# 6 从替换模型到环境模型

尽管我们上一节中实现的解释器已经可以进行函数的调用，但你可能对其并不太满意。对于标识符的处理，直观上的处理应该是“找到它绑定的值”。但是我们不仅没这样做，还在遇到标识符时直接抛出错误！不过对于该解释器来说，这种行为也并没错。但是我们写解释器就是为了让其_理解并解释_我们设计的语言，而该解释器现在看来并没有达成我们的意愿。

使用替换模型的另一个问题是：需要遍历源程序的次数。程序的所有部分都将被解释求值，更合理的行为显然是只计算需要被计算的条件分支。替换模型必须遍历程序的所有部分——比如说，条件分支中不执行的分支——而且还需要遍历程序两遍，一遍替换，一遍解释。

__习题__

> 替换模型会影响程序的时间复杂性吗？

替换模型还有一个问题，他的结构受限于代码的表示法。当然，我们的解释器需要处理代码，但是其他实现方式——比如说编译器——并不需要存贮整个代码。采取更一般的策略，不依赖于具体实现方式显然更合理。

## 6.1 介绍环境模型

直觉告诉我们，解决第一个问题的方法是，解释器可以在某种形式的字典里面“寻找”标识符；解决第二个问题的方法是，*延迟*替换。幸运的是，这两点结合起来还能解决第三个问题。字典里面记录的是_可以替换的内容_，而并不对原始程序进行修改。因为记录下了可替换的内容，而并非直接替换，我们可以延迟进行替换的步骤。记录替换内容的数据结构被称为_环境_。使用环境避免了源代码级别的重写，并且和底层的计算机表示法对应。环境中的每一个结合关系被称为_绑定_。

注意，这里我们要修改的是编程语言的*实现策略*，而不是*修改语言本身*。因此用于表示程序的数据结构，甚至解释器执行结果都不应发生改变。因此我们可以将之前那个解释器当作我们这次要写的解释器的“参考实现”。我们应该创建一个测试生成器，生成很多测试让两个解释器执行，确保它们返回的结果相同。理想情况下，我们应该*证明*两个解释器行为一致，事实上它是一个很好的高阶课题。

首先，我们来定义环境的数据结构。环境是名字与什么的绑定的列表？

__思考题__

> 这里定义数据结构时，很自然的问题就是，环境中将名字映射成了什么东西。但是我们可以问一个更好更基本的问题，我们如何得出这个很自然问题的答案？

记住我们这里引入环境是为了推迟替换过程。因此，答案在替换中。我们在[上一章最后一节](./chap5.md#注意还有个重要的东西)中讨论过，我们希望直接将名字替换为计算结果，即对应于函数的贪婪求值策略。因此同样的，环境中应该将名字映射为求值结果。

```racket
(define-type Binding
  [bind (name : symbol) (val : number)])

(define-type-alias Env (listof Binding))
(define mt-env empty)
(define extend-env cons)
```

## 6.2 环境模型解释器

现在，我们可以修改解释器了。解释器中除最简单的情况（数）外其它情况的代码均需要重新考虑：

```racket
(define (interp [expr : ExprC] [env : Env] [fds : (listof FunDefC)]) : number
  (type-case ExprC expr
    [numC (n) n]
    <idC-case>          ;; 待重写
    <appC-case>         ;; 待重写
    <plusC/multC-case>) ;; 待重写
    )
```

算术操作是比较好写的。回忆一下，这其中未涉及到替换过程，因此无需特别处理，环境不会发生改变：

```racket
;; <plusC/multC-case> ::=
[plusC (l r) (+ (interp l env fds) (interp r env fds))]
[multC (l r) (* (interp l env fds) (interp r env fds))]
```

接下来我们处理标识符。显然，现在遇到标识符不应该直接报错了。我们应该在当前环境中查找对应的值：

```racket
[idC (n) (lookup n env)]
```

__思考题__

> 实现 lookup 函数。

最后，处理函数调用。注意到在替换模型的解释器中，唯一创建新替换的部分就是函数调用。因此这个地方会是需要创建绑定的地方。第一步，跟之前一样，提取函数定义：

```racket
;; <appC-case> ::=
[appC (f arg) (let ([fd (get-fundef f fds)])
               <appC-interp>)]
```

之前，我们是先进行替换，然后解释。现在剔除掉替换这个步骤，我们首先记录下要替换的东西，然后直接进入解释函数体，并且需要记下被延迟的替换：

```racket
;; <appC-interp>
(interp (fdC-body fd)
        <appC-interp-bind-in-env>
        fds)
```

也就是说，函数定义部分保持不变；我们照旧解释函数的主体部分；不过解释过程要被放在一个新的环境中，该环境包含了函数形式参数的绑定。接下来定义绑定过程：

```racket
;; <appC-interp-bind-in-env-take-1>
(extend-env (bind (fdC-arg fd)
                  (interp a env fds))
            env)
```

这里被绑定的参数是函数的形式参数（和之前被替换的一样）。绑定的值是函数参数解释求值的结果（因为我们决定采用贪婪求值策略）。最后，这将扩展现有的环境。类型检查确保我们得到的代码是正确的。

最后加上lookup函数的实现：

```racket
(define (lookup [name : symbol] [env : Env])
  (if (empty? env)
      (error 'lookup "Name not bound")
      (let ([binding (first env)])
        (if (symbol=? name (bind-name binding))
            (bind-val binding)
            (lookup name (rest env))))))
```

注意到，当环境中找不到标识符绑定的值时依旧会报错。但是现在对于标识符是否被绑定的判断从解释器中被剥离出来，由 lookup 函数根据当前环境来决定。

到此为止，已经得到了一个完整的使用环境模型的解释器，你可以测试一下，比如下面这几个例子：

```racket
(test (interp (plusC (numC 10) (appC 'const5 (numC 10)))
              mt-env
              (list (fdC 'const5 '_ (numC 5))))
      15)

(test (interp (plusC (numC 10) (appC 'double (plusC (numC 1) (numC 2))))
              mt-env
              (list (fdC 'double 'x (plusC (idC 'x) (idC 'x)))))
      16)

(test (interp (plusC (numC 10) (appC 'quadruple (plusC (numC 1) (numC 2))))
              mt-env
              (list (fdC 'quadruple 'x (appC 'double (appC 'double (idC 'x))))
                    (fdC 'double 'x (plusC (idC 'x) (idC 'x)))))
      22)
```

所以，我们是已经完成任务了，对吧？

__思考题__

> 找找看有什么 bug。


## 6.3 正确的进行延迟求值

考虑下面这个测试：

```racket
(interp (appC 'f1 (numC 3))
        mt-env
        (list (fdC 'f1 'x (appC 'f2 (numC 4)))
              (fdC 'f2 'y (plusC (idC 'x) (idC 'y)))))
```

在我们的环境解释器中，它的结果为 7。结果正确吗？

将上面的代码转成 Racket 代码为：

```racket
(define (f1 x) (f2 4))
(define (f2 y) (+ x y))

(f1 3)
```

考虑其求值过程。 `(f1 3)` 将函数 `f1` 的函数体中 `x` 替换为 3，于是结果为 `(f2 4)` 的值。但是注意到在函数 `f2` 中， 标识符 `x` _未绑定到任何值_！理所当然的，Racket 报错了。

事实上，我们前一章中的替换模型解释器也会报错！

为什么我们的替换模型会报错呢？是因为，我们仅会在 `f1` 的函数体内将标识符 `x` 替换为数 3 的表示（这是显而易见的事：`x`是`f1` 的参数；如果其它函数的参数名碰巧也为 `x`，那也是个*不同的x*）。当我们计算`f2`时，它的函数体中 `x` 没有被替换，因此报错了。

那么我们环境模型的问题到底出在哪呢？请仔细观察，这一点很微妙。只有函数调用过程会改变环境，我们重点观察它。注意到，通过将形式参数替换成实际参数是通过_扩展当前环境_实现的。在我们的例子中，不仅`f1` 被调用时，`f1` 的参数值和参数名 `x` 的绑定被添加到环境中，在计算 `f2` 时，这个绑定仍然还在！即，添加到环境中的绑定不会被剔除，所有历史绑定都被保留了。

由于前面说过，环境模型是上一章替换模型的替代实现策略——我们的语言意义不应该发生改变——我们需要修改解释器保证它们行为一致。具体来说，我们不应该让解释过程保留所有历史绑定。应该为每个新的函数创建一个干净的环境。很容易实现：

```racket
;;<appC-interp-bind-in-env> 
(extend-env (bind (fdC-arg fd)
                  (interp a env fds))
            mt-env)
```

到此，我们重现了替换模型解释器的行为。


## 6.4 作用域

上面那个产生 `7` 那个非预期结果的解释器中的环境模型，事实上就是大家熟悉的*动态作用域（dynamic scope）*。它意味着随着程序的执行，环境中的绑定不断增加。于是，一个标识符是否被绑定取决于程序的执行历史。这应该被视作程序语言设计的缺陷。它增加了对其进行处理的工具的复杂度，如编译器、IDE，也使得其代码难于阅读维护。

与之对应的，替换模型，以及上面正确实现的环境模型，给我们带来的是*词法作用域（lexical scope）* 或称*静态作用域（static scope）*。这里“词法（lexical）”指的是 “通过源码即可确定”；“静态（static）”指的是“不需运行程序即可确定”，可以看出，在这个地方，它们指代的意义相同。
在遇到一个标识符时，我们希望知道两件事：

1. 它是否被绑定了？
2. 如果被绑定，在何处被绑定的？

这里“何处被绑定”指的是当一个名字在多处被绑定，当前这个名字对应哪个绑定。一般来说，这种问题在动态作用域的语言中不能静态的的到答案，因此你的 IDE 不能很好的提示你某个变量是在哪个地方被定义的。因此，即使随着对象、线程等的引入使得作用域更为复杂，我们仍需尽量记住静态作用域的优势。

### 6.4.1 动态作用域到底有多糟糕

可能在看到上面的例子，你会觉得我们是在小题大作。但是，请考虑这两件事：

1. 要真正理解一个动态作用域的程序，你*必需阅读整个程序*。不管你怎么将程序进行解耦成易于理解的小的部分，如果程序中有一个自由变量呢。
2. 要理解绑定关系，不仅涉及到程序的体积，还牵扯到控制流的复杂度。考虑一个使用了很多回调的程序，你需要追踪整个调用过程来确定一个标识符的值的来源。

还不够有说服力？让我们把程序中的表达式替换为：

```racket
(if (moon-visible?)
    (f1 10)
    (f2 10))
```

假设`moon-visible?`函数在新月的夜晚其值为假,其他情况下为真。于是我们的程序应当在新月夜晚报错，未绑定变量，而在其他情况下返回某个值。

__习题__

> 在多云的夜晚呢？

### 6.4.2 顶层作用域

当我们深入思考很多语言中顶层作用域中的定义时，事情会变得更加复杂。例如，一些版本的 Scheme（典型的词法作用域语言）允许你写出这样的程序：

```racket
(define y 1)
(define (f x) (+ x y))
```

看上去好像函数 `f` 中的 `y` 来源很清晰，不过：

```racket
(define y 1)
(define (f x) (+ x y))
(define y 2)
```

它是合法的，且计算 `(f 10)` 时它返回 12。取最后一个定义就行了！你可能想。但是：

```racket
(define y 1)
(define f (let ((z y)) (lambda (x) (+ x y z))))
(define y 2)
```

这时候，`z` 绑定的是第一个 `y` 的定义值，lambda 函数内部的 `y` 被绑定了第二个 `y` 定义。事实上可以通过词法作用域解释这种行为，但是它让情况变得异常复杂，可能避免这样的重定义是一种比较好的选择。Racket 正是这样做的。

> 很多“脚本”语言都有类似的问题。所以网上你会看到很多人搞不清楚某种语言到底是静态还是动态作用域的。其实很多情况下人们只是在比较函数内的行为（通常是静态作用域）还是顶层的行为（通常是动态作用域）。请注意。

## 6.5 暴露环境

如果是实现一个供别人使用的解释器，一个明智的选择是将环境隐藏起来，给用户提供的借口只接收一个表达式，外加一系列函数定义，然后我们在程序内部从空白的环境开始调用解释器。这样也不用将实现细节暴露给用户，也不会由于用户提供错误的环境导致问题。然而，有些时候，暴露环境参数也是很有用的。比如如果一门语言希望默认将 pi 绑定到 3.2 （[Indiana](https://en.wikipedia.org/wiki/Indiana_Pi_Bill)）。
