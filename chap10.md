# 10 对象

当一门语言将函数作为值，它便为开发者提供了最为自然的用于表示计算过程的最小单位。任何一门语言都允许函数参数为字符串、数字这种被动数据（passive data），但是支持参数为 active data（翻译无能）是非常吸引人的：即传递进去的数据实际上是一个计算过程，你可以通过它计算得出一个结果，可能是针对特定信息的响应。如果传递进函数 `f` 的 active data 是一个词法作用域函数，那么调用者就可以在无需将某些数据泄漏给 `f` 的情况下使用这些数据了，这给安全和隐私提供了基石。正因如此，词法作用域函数成为很多安全编程技巧设计的核心。

函数是一种非常美好的东西，从概念上来说，太非常简洁，但是太过简洁了。有时候我们希望多个函数闭合于一份共享的数据；当这份数据被某个函数改变而我们希望其他函数能够看到这些改变是尤为如此。

## 10.1 不支持继承的对象

最简单的关于对象的定义为——可能是唯一的所有谈论对象的人都能统一的定义——对象是：

* 是一个值
* 该值能够将一些名字映射成
* 其它东西：其它值或者“方法”

从极简主义的角度来说，方法似乎就是函数，由于在自己的语言中已经实现了函数，我们先放下它们之间的区别。

> 之后我们会发现“方法”和函数极其相似，但是在一些很重要的方面有所不同，主要是调用方式及所绑定的东西上。

### 10.1.1 对象的核心数据结构

从我们实现的将函数作为第一类值的语言开始，实现一个最简单的对象系统。首先扩展值的定义：

```scheme
(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)]
  [objV (ns : (listof symbol)) (vs : listof Value)])
```

然后添加表达式语法以支持对象表达式：

```scheme
[objC (ns : (listof symbol)) (es : (listof ExprC))]
```

对该对象表达式的计算非常简单：直接计算表达式列表中的每个表达式即可：

```scheme
[objC (ns es) (objV ns (map (lambda (e)
                              (interp e env))
                            es))]
```

到目前为止我们还不能使用一个对象：很显然，我们没有获取对象内部内容的构造。于是，下面我们来给它添加一个获取成员的操作符：

```scheme
[msgC (o : ExprC) (n : symbol)]
```

添加它的动机明显，行为直白：

```scheme
[msgC (o n) (lookup-msg n (interp o env))]
```

**练习**

> 实现函数
>
> ```scheme
> ;; lookup-msg : symbol * Value -> Value
> ```
>
> 第二个参数期望值应该是 `objV`。

原则上 `msgC` 可以被用于获取任意类型的成员，但是简单起见，我们假设成员中只有函数。使用它，需要给其传入参数值。将它实现到核心语言会使语法有点笨拙，使用语法糖实现这点。我们创建如下语法糖：

```scheme
[msgS (o : ExprS) (n : symbol) (a : ExprS)]
```

解开成 `msgC` 并调用：

```scheme
[msgS (o n a) (appC (msgC (desugar o) n) (desugar a))]
```

至此，一个包含对象为第一类值的语言就诞生了。例如，下面是对象定义和调用：

```scheme
(letS 'o (objS (list 'add1 'sub1)
               (list (lamS 'x (plusS (idS 'x) (numS 1)))
                     (lamS 'x (plusS (idS 'x) (numS -1)))))
      (msgS (idS 'o) 'add1 (numS 3)))
```

它计算得 `(numV 4)`。

