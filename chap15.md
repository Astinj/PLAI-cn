# 15 静态地检查程序中的不变量：类型

当程序变得更大或者更为复杂时，程序员希望能有工具帮助他们描述、验证程序中的不变量。顾名思义，不变量指的就是关于程序组成元素的那些不会发生改变变陈述。例如，当我们在静态类型语言中写`x : number`时，表示x中存放的总是个数，程序中依赖x的部分都可以认定它是个数的这个事实不会改变。我们将会看到，类型只是我们想要称述各类不变量中的一个，静态类型检测——一个分支众多的技术家族——也只是用于控制不变量的众多方法中的一个。

## 15.1 Types as Static Disciplines

本章我们将专注于**静态类型检查**：即在程序执行前检查（声明的）类型。之前使用的静态类型语言已经让我们积攒了一些这种形式程序的经验。我们将探索类型的设计空间及这些设计中的权衡取舍。尽管类型是控制不变量的一种非常强大且有效的方法，最后我们还是会考察一些其它可用的技术。

考虑下面这段静态语言写就的程序：

```Racket
(define (f [n : number]) : number
  (+ n 3))

(f "x")
```

程序开始执行前我们就会得到一个静态类型错误。使用普通Racket写就的同样的程序（没有类型注解）只在运行时出错：

```Racket
(define (f n)
  (+ n 3))

(f "x")
```

__练习题__
> 如何判断错误是在程序执行前还是运行时抛出的？

考虑下面这段Racket程序：

```Racket
(define f n
  (+ n 3))
```

它也是在程序执行前就遇到错误——语法解析错误——终止。尽管我们认为语法解析和类型检查有所不同——通常是因为类型检测是针对已经被解析好的程序做的——但是将语法解析看作一种最简单形式的类型检查也很有用：它（静态地）判定程序是否遵守指定**上下文无关**语法。随后，类型检查判定它是否遵守指定**上下文相关**（或者一个更丰富的）语法。简而言之，类型检查从某种程度上看是语法解析的泛化，它们都是通过**语法**控制程序遵循指定的规则。

## 15.2 关于类型的一种经典看法

我们先介绍一种传统的类型核心语言；然后我们将探索扩展和变种。

### 15.2.1 简单的类型检查器

首先定一个类型检查器，我们需要达成两件事：我们**静态类型核心语言**的语法，对应的类型。

先回到我们之前实现过的[函数作为值](chap7.md)的那一版语言，但是得添加赋值及一些其它稍复杂的东西（后面将讲到其中的一些）。我们需要为该语言添加类型注解。按惯例，我们不给常数或者基本类型上的操作如加法强加类型信息；instead, we impose them on the boundaries of functions or methods.。....TODO:

考虑到以上决定，我们静态类型的核心语言变成了：

```Racket
(define-type TyExprC
  [numC (n : number)]
  [idC (s : symbol)]
  [appC (fun : TyExprC) (arg : TyExprC)]
  [plusC (l : TyExprC) (r : TyExprC)]
  [multC (l : TyExprC) (r : TyExprC)]
  [lamC (arg : symbol) (argT : Type) (retT : Type) (body : TyExprC)])
```

每个函数都添加了其参数及返回值类型的注解。

现在我们需要对类型语言作出选择。我们遵从传统定义即类型是**一组值的集合的抽象**。我们的语言中有两类值：

```Racket
(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : TyExprC) (env : Env)])
```

因此我们有两种类型：一种是数的类型，另一种是函数的类型。

即使是数的类型也并不那么简单直接：数类型应该记录何种信息？大部分语言中，实际上有**很多**数类型，TODO:甚至没有一个用于表示“数”。然而我们忽略数的层级结构，对于我们来说有一种数的类型足矣。Having decided that, do we record additional information about which number? We could in principle, but we would soon run into decidability problems.

至于函数，我们有更多信息：参数类型，声明的结果类型。TODO

```Racket
(define-type Type
  [numT]
  [funT (arg : Type) (ret : Type)])
```

既然我们已经确定了语言的术语和类型结构, 下面确保语言中的类型错误的一致性（且，我们强制所有非类型错误的错误不会被类型检查器处理）。显然有三种形式的类型错误：

* `+`存在不是数的参数，也即不是`numT`。
* `*`存在不是数的参数。
* 函数调用时函数位置的表达式不是一个函数，也即不是`funT`。

__思考题__
> 还有其它形式的类型错误吗？

事实上我们遗漏了一个：

* 函数调用时实参的类型和函数的形参的类型不一致。

It seems clear all other programs in our language ought to type-check.

关于类型检查器的签名，初步设想时，很可能是接受一个表达式作为参数，返回指明该表达式是否通过检查的布尔值。由于我们知道表达式中包含标识符，所以我们很快清楚需要一个**类型环境**，它将名字映射到类型，类似于我们之前用到的值环境。

__练习题__
> 定义与**类型环境**相关的数据类型以及相关函数

因此，我们开始写的程序的结构大致是这样：

```Racket
;; <tc-take-l> ::=
(define (tc [expr : TyExprC] [tenv : TyEnv]) : boolean
  (type-case TyExprC expr
    <tc-take-1-numC-case>
    <tc-take-1-idC-case>
    <tc-take-1-appC-case>))
```

正如上面程序中列出的要处理几种情形所表明的，这种方法行不通。我们很快将知道这是为什么。

首先处理简单的情形：数。数需要进行类型检查吗？就其自身而已，当然需要；它可能处在一个上下文要求不应该是个数的位置，但是这种错误应该在其它地方被检查。因此：

```Racket
;; <tc-take-1-numC-case> ::=
[numC (n) true]
```

下面处理标识符。如何判断数是否通过类型检查呢？同样，就其自身来说，如果是一个被绑定过的标识符来说，总是通过检查的；它可能不是上下文要求的那种类型，但是这种错误应该在其它地方检查。因此，我们得出：

```Racket
;; <tc-take-1-idC-case> ::=
[idC (n) (if (lookup n tenv)
             true
             (error 'tc "not a bound identifier"))]
```

上面的代码可能让你感觉不太对：如果标识符未绑定的话，`lookup`会抛出异常，因此没必要再去重复处理该情况（事实上，代码永远不会执行到`error`调用那个分支）。但是先不管，继续推进。

下面来解决函数调用。我们应该首先检查函数位置，确定它是个函数，然后确保实际参数的类型和该函数定义时声明的形式参数类型相同。例如，函数位置可能是个数TODO

```Racket
;; <tc-take-1-appC-case> ::=
[appC (f a) (let ([ft (tc f tenv)])
              ...)]
```

对于`tc`的递归调用只能让我们知道函数位置是否是个函数。如果它是个函数，怎么知道它具体是什么类型的呢？如果是个简单函数定义的话，我们可以直接从语法上取得其参数和返回值的类型。但是如果是个复杂的表达式，我们就需要一个能**计算**出表达式类型的函数。当然，只有一个表达式是个类型正确的表达式时该函数才能返回类型结果；否则的话它将不能得出一个结果。换句话说，**类型检查**是该**类型计算器**的一个特殊情形！因此，我们应该考虑该归纳不变量增强`tc`功能：即，返回表达式的类型，而不仅仅返回表达式是否能通过类型检查。只要有有返回值，该表达式就通过了类型检查；否则它会抛出错误。

下面我们来定义这个类型“检查器”。

```Racket
;; <tc> ::=
(define (tc [expr : TyExprC] [tenv : TyEnv]) : Type
  (type-case TyExprC expr
    <tc-numC-case>
    <tc-idC-case>
    <tc-plusC-case>
    <tc-multC-case>
    <tc-appC-case>
    <tc-lamC-case>))
```

现在填充具体实现。数很简单：它的类型就是数类型。

```Racket
;; <tc-numC-case> ::=
[numC (n) (numT)]
```

与之相似，标识符的类型从环境中查询得到（如果其未被绑定则会抛出错误）。

```Racket
;; <tc-idC-case> ::=
[idC (n) (lookup n tenv)]
```

到此，我们可以观察到该类型检查器与解释器之间的一些异同：对于标识符，两者做的事情其实一样（只不过这里返回的是标识符的类型而不是一个实际的值），对于数的情况，这里返回了抽象的“数”而不是具体的数。

下面考虑加法。必须让其两个子表达式都具有数类型；如果满足该条件，则加法表达式本身返回的是数类型。

```Racekt
;; <tc-plusC-case> ::=
[plusC (l r) (let ([lt (tc l tenv)]
                   [rt (tc r tenv)])
               (if (and (equal? lt (numT))
                        (equal? rt (numT)))
                 (numT)
                 (error 'tc "+ not both numbers)))]
```

通常在处理完加法的情形之后，对于乘法我们就一笔带过了，但是这里显式处理一下它还是很有教益的：

```Racket
;; <tc-multC-case> ::=
[multC (l r) (let ([lt (tc l tenv)]
                   [rt (tc r tenv)])
               (if (and (equal? lt (numT))
                        (equal? rt (numT)))
                   (numT)
                   (error 'tc "* not both numbers")))]
```

__思考题__
> 看出其中的区别了吗？

是的，基本上没啥区别！（仅有的区别是在`type-case`时使用的分别`multC`和`plusC`，以及错误提示信息稍有不同）。这是因为，从（此静态类型语言）类型检查的角度来说，加法和乘法没有区别，更甚，任意接受两个数作为参数返回一个数的函数都没有区别。

注意到代码解释和类型检查之间另一个不同点。它们的参数都是数。解释器返回加或者乘它们得到的确切数值，但是类型检查器并不在乎具体的数值：因此该表达式的计算结果（`(numT)`）是个常数，两种情形返回都是该常数。

最后还剩下两个难一点的情形：函数调用和函数。我们已经讨论过怎么处理函数调用：计算函数以及参数表达式的值；确保函数表达式为函数类型；检查参数类型和函数形参类型相容。如果这些条件满足，函数调用得到的结果类型就是函数体计算结果的类型（因为运行时最终的返回值就是计算函数体得到的值）。

```Racket
;; <tc-appC-case>
[appC (f a) (let ([ft (tc f tenv)]
                  [at (tc a tenv)])
              (cond
                [(not (funT? ft))
                 (error 'tc "not a function")]
                [(not (equal? (funT-arg ft) at))
                 (error 'tc "app arg mismatch")]
                [else (funT-ret ft)]))]
```

最后还剩下函数定义。函数有一个形参，它在函数体中可能用到；除非它被绑定到环境中，不然函数体应该不太可能通过类型检查。因此我们需要扩展类型环境，添加形参与其类型的绑定，然后在扩展后的环境中检查函数体。最终计算得到的函数体的类型应该和函数定义中指定的函数返回值类型相同。如果满足了这些，该函数的类型就是指定参数类型到函数体类型的函数。

__练习题__
> 上面说的“不太可能通过类型检查”是什么意思？

```Racket
[lamC (a argT retT b)
      (if (equal? (tc b (extend-ty-env (bind a argT) tenv)) retT)
          (funT argT retT)
          (error 'tc "lam type mismatch"))]
```

注意到解释器与类型检查器另一个有趣的不同点。解释器中，函数调用负责计算参数表达式的值，扩展环境，然后对函数体求值。而这里，函数调用的情形中的确也检查了参数表达式，但是没有涉及到环境的处理，直接返回了函数体的类型，而没有**遍历它**。对函数体的遍历检查过程实际是在检查函数**定义**的过程中进行的，因此环境也是在这个地方才实际被扩展的。


### 15.2.2 条件语句的类型检查

考虑为上面的语言添加条件语句，即使最简单的if表达式都会引入若干设计抉择。这里我们先讨论其中的两个，后面会回过头来再讨论一个。

1. 条件表达式的类型应该是什么？某些语言中它必须计算得到一个布尔值，这种情况下我们需要为我们的语言添加布尔值（这可能是个好主意）。其它语言中，它可以是任意值，其中定义了一些“真值”类型，其它的都是“假值”。
2. `then-`和`else-`两个分支之间的关系应该是什么呢？一些语言中它们类型必须相同，因此整个if表达式有一个确定无歧义的类型。其它语言中，两个分支可以有不同的类型，这不仅会极大的改变静态类型语言的设计和它的类型检查器，还改变了编程语言的本质。

__练习题__
> 为该静态语言添加布尔值。它意味着什么？在典型的语言中还需要什么？

__练习题__
> 为条件语句添加类型规则，其中条件表达式应该计算得到布尔值，且`then-`和`else-`分支必须有相同的类型，同时该类型也是整个条件语句的类型。

### 15.2.3 代码中的递归

现在我们已经得到了一个基本的编程语言，下面为其添加递归。之前我们实现过递归，可以很容易的通过语法糖实现。很快将发现这里它比之前的情况要复杂一些。

#### 15.2.3.1 支持静态类型的递归的初次尝试

首先尝试表示一个简单的递归函数。最简单的当然就是永远循环的函数。我们可以仅使用函数实现该函数吗？可以：

```Racket
((lambda (x) (x x))
 (lambda (x) (x x)))
```

我们的语言中已经支持将函数作为值。

__练习题__
> 为什么它会构成一个无限循环？What subtle dependency is it making about the nature of function calls?

现在我们的语言是一个强制我们为所有函数添加类型注解的静态类型语言。我们来为该函数添加类型注解。简单起见，假设从现在开始我们写的程序使用的语法是静态类型的表层语法，去语法糖将帮我们将其转换为核心语言。

首先注意到，我们有两个完全一样的表达式，它们互相调用。历史原因，整个表达式被成为Ω（希腊字母），那两个一样的子表达式被称为ω（希腊字母）。两个表达式长的一样并不意味着它们就一定是同种类型的，因为它还依赖于具体使用环境中对于不变量的定义。这个例子中，观察到x被绑定到ω，于是ω将出现在在`(x x)`式子的第一个和第二个部分。即，确定其中一个表达式的类型，另一个式子的类型也被确定。

因此，尝试计算ω的类型；我们称该类型为γ。很显然它是一个函数类型，而且该函数是一个单参数的函数，所以它的类型必然是`φ -> ψ`这种形式的。该函数的参数类型是什么？就是ω自己的类型。也即，传入φ的值的类型就是γ。因此，ω的类型是γ，也即`φ -> ψ`，展开即`(φ -> ψ) -> ψ`，进一步展开得`((φ -> ψ) -> ψ) -> ψ`，还可以继续下去。也即，该类型不能用有限的字符串写出来！

__思考题__
> 你注意到了我们刚做的的微妙但重要的飞跃吗？

### 15.2.3.2 程序终止

明显观察到Ω的类型的计算过程——导致γ的产生——似乎遇到了严重的问题。然而，我们从中得出这样的结论：这种类型不能用有限长度的字符串表示，但是这只是直觉的结果，并没有给出证明。事实上，还有更奇怪的为真的命题：在我们迄今定义的类型系统中，我们根本不能给出Ω的类型！

这是一个很强的表述，但事实上我们可以给出更强的描述。目前为止我们使用的静态类型语言有一个属性，称为强归一化（strong normalization）：每个有类型的表达式都会在有限步骤后终止计算。换句话，这个特殊的（奇异的）无限循环程序并不是唯一不可获得其类型的程序；任何无限循环（或潜在存在无限循环）的程序在当前这个语言中都不可以获取其类型。一个简单的直觉说明可以帮助我们理解，任何类型——必须能被有限长度的字符串表示——只能包含有限个`->`，每次调用会产生一个`->`，因此我们只能进行有限数目的函数调用。

如果我们的程序只允许非转移程序（[straight-line program](https://en.wikipedia.org/wiki/Straight-line_program)），这点也无足为奇。但是，我们有条件语句，甚至还有可以被传来传去的作为值的函数，通过这些我们可以编码得到任何我们想要的数据结构。然而我们仍能得到这个保证！这使得这个结果令人吃惊。

__练习题__
> 试着使用函数分别在动态类型和静态类型语言中中实现列表。你看到了什么？这说明了这种类型系统对于编码产生了何种影响？

这个结果展示了某种更深层次的东西。它表明，和你可能相信的——类型系统只是用来避免一些程序BUG在运行时才被发现——相反，类型系统可能改变语言的语义。之前我们通过一两行程序就能写出一个无限循环的程序，现在我们一个都写不出来。这也表明，类型系统不仅可以建立关于一个特定程序的不变量，还能建立关于语言本身的。如果我们想要非常自信的确定一个程序将会终止，我们只要将它用该语言写出来然后传给类型检查器即可。

一门用其书写的所有程序都将终止的语言有什么用处？对于通用变成来说，当然没用。但是在很多特别的领域，这是一个非常有用的保证。例如，你要实现一个复杂的调度算法；你希望知道你的调度程序是否保证终止，以便那些被调度的任务会被执行。还有其它很多我们能在这种保证上获益的领域：路由器中的包过滤器；实时的时间处理器；设备初始化程序；配置文件；单线程JavaScript中的回调；甚至编译器或链接器。每种情况下，我们都有一个不成文的期望，即这些程序最终会终止。而现在我们有一个语言能保证这点——且这点是不可测试的。

> 这不是假想的例子。在ML语言中，链接模块基本上就是使用这种静态类型语言来编写模块链接规范。这意味着开发人员可以编写相当复杂的抽象概念——毕竟可以将函数作为值使用——且同时链接过程被保证会终止，产生一个最终程序。

### 15.2.3.3 静态类型递归

这就意味着，之前国门可以只通过去语法糖来实现`rec`，现在则必须在我们的静态类型语言中显式的实现。简单起见，我们仅考虑`rec`的一种特殊形式——它涵盖了常见用法，即递归标识符被绑定到函数。因此，表层语法中，我们可能写出如下的累加函数：

``` Racket
(rec (Σ num (n num)
        (if0 n
             0
             (n + (Σ (n + -1)))))
  (Σ 10))
```

其中，`Σ`是函数名，`n`为其参数，`num`为函数参数以及返回值的类型。表达式`(Σ 10)`表示使用该函数计算从10累加到0的和。

如何计算该种表达式的类型？显然，我们需要为函数体中的`n`绑定我们赋予其的类型；从对函数的类型的考察中我们就知道这么多。那么`Σ`呢？显然在检查`(Σ 10)`的类型时，它应该在类型环境中被绑定，它的类型必须为`num -> num`。在检查函数体时，其同样需要被绑定到这种类型。（也要注意，函数体返回值的类型需要和事先声明的返回类型相同。）

现在我们可以看到如何打破类型有限性的束缚。程序代码中，我们只能编写有限数量的 `->` 类型。但是，这种递归类型的规则在函数体中引用自身时复制了 `->`，从而确保有无穷的函数调用。这是我们无穷箭矢的颤音。

实现这种规则的代码如下。假设`f`被绑定到函数的名字，`aT`是函数参数的类型，`rT`为返回类型，`b`是函数体，`u`是函数的使用：

``` Racket
;; <tc-lamC-case> ::=
[recC (f a aT rT b u)
      (let ([extended-env
             (extend-ty-env (bind f (funT aT rT)) tenv)])
        (cond
          [(not (equal? rT (tc b
                               (extend-ty-env
                                 (bind a aT)
                                 extended-env))))
            (error 'tc "body return type not correct")]
          [else (tc u extended-env  )]))]
```

## 15.2.4 数据中的递归

我们已经见识了静态类型递归程序，但是它还不能使我们创建递归的数据。我们已经有一种递归数据——函数类型——但是这是内建的。现在还没看到开发人员如何创建自己的递归数据类型。

### 15.2.4.1 递归数据类型定义

当我们说允许程序员创建递归数据时，我们实际在同时谈论三种东西：

* 创建新的类型
* 让新的类型的实例拥有一个或多个字段
* 让这些字段中的某些指向与自己有相同类型的实例

实际上，一旦我们允许了第三点，我们就允许了令一点：

* 允许该中类型中非递归的基本情况的存在

这些设计准则的组合产生了通常被称为代数数据类型的东西，比如我们的静态语言中支持的类型。举个例子，考虑下面这个二叉树的定义：

``` Racket
(define-type BTnum
  [BTmt]
  [BTnd (n : number) (l : BTnum) (r : BTnum)])
```

注意到如果这个新的数据类型没有名字 BTnum，我们将不能在 BTnd 中引用回该类型。类似的，如果不被允许定义除 BTnum 之外的其它构造，那么就不能定义 BTmt，这样就无法终止递归。当然，最后我们需要多个字段（如 BTnd 中的一样）来构造有用和有趣的数据。换句话说，所有这三种机制被大宝在一起，因为它们结合在一起才最有用。（但是，有些语言确实允许定义独立结构。后面【引用】我们将回来讨论这个设计决策对类型系统的影响）。


我们关于递归的初始表示的讨论暂告一个段落，但它有一个严重的问题。我们并没有真正解释这个新的数据类型 BTum 的来源。因为我们不得不假装它已经在我们的类型检查器中实现了。然而，为每个新的递归类型改变我们的类型检查器有点不切实际——这就像我们需要为每个新出现的递归函数去修改解释器一样！相反，我们需要找到一种使得这种定义成为静态类型语言固有能力的方法。后面【引用】会回到这个问题。

> 后面我们会讨论如何参数化类型。

这种风格的数据定义有时也被称为**乘积的和**，“乘”指代字段组合成一个不变量的方式：例如，一个 BTnd 的合法值是传递给 BTnd 构造器的每个字段合法值的叉乘。“和”是所有这些不变量的总数：任何给定的 BTnum 值是其中之一。（将“乘”想作“且”，“加”想作“或”。）

### 15.2.4.2 Introduced Types

### 15.2.4.3 模式匹配和去语法糖

## 15.2.5 类型，时间和空间

## 15.2.6 类型和赋值

## 15.2.7 中心定理：类型的可靠性
