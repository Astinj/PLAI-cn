# 11 内存管理

## 11.1 垃圾

我们使用**垃圾（Garbage）**指代那些被分配但是不在被需要的内存。编程语言的运行时系统中有两类典型的内存分配方式。一种是环境：使用堆栈结构存放静态作用域相关信息，函数调用返回时，直接释放为其分配的环境内存，不需要考虑太多。与之相对的，堆上分配的内存需要追踪值生命周期，它可能在创建其的作用域外面仍然存活——而且有可能会一直存在。因此对于堆上分配的内存产生的垃圾需要采取一些不同的策略。

内存回收方式有很多种，大体可以分到两个阵营中：人工和自动。人工的方式依赖于开发者去跟踪内存使用，回收不需要的内存。一般认为，人并不擅长做这种事（但是有时候人能获取到机器所不能获取的一些信息）。因此，几十年来，自动化的方法已经变得几乎无处不在。

## 11.2 什么样的垃圾回收是“正确的”？

垃圾回收进行的既不能过早（可靠性，soundness）也不能太迟（完全性，completeness）。两种情况都被认为是有问题的，但是它们造成的影响程度不同：过早的垃圾回收糟糕得多。这是因为如果过早回收了栈上内存，后续程序继续再该内存上进行读写，而这已经是无意义的。它会导致程序不正确，极端情况下，可能会产生安全问题。与之相对的，过迟的垃圾回收会导致性能损失，并且可能最终导致由于内存耗使而程序终止，尽管此时理论上存在可用内存（只是还没有被回收）。这种性能上的损失及潜在的被迫终止的可能性很烦人，特别是在运行着关键任务的系统中这可能会个重大问题，不过，至少程序没有进行无意义的运算。

理想的情况是我们能够拥有所有的这三个特性：自动化（automation），可靠性（soundness），完全性（completeness）。然而，这里我们面对的是不可兼得的情形，必须要进行权衡。理想情况下人能够既实现可靠性和完全性，但实践中实现其中任意一个都很少见。计算机自动化的同时可以提供可靠性和完全性中的一个，可计算性论证表明，自动化的计算过程不能同时达成这两者。实践中，自动化技术一般选择实现可靠性，出于一下原因：（a）它造成的损害相对小，（b）相对更容易实现，（c）且在添加一些人工干预的情况下，可以非常接近完全性。

## 11.3 人工回收

人工的最彻底的方式是将所有内存的回收交由人进行。例如，在 C 语言中提供了两个基本操作：`malloc` 用于分配内存，`free` 用于释放内存。`malloc` 接收要分配内存的容量为参数，返回一个在堆上分配的值的引用；`free` 接收引用作为参数，释放引用关联的内存。

### 11.3.1 完全人工内存回收的代价

首先考虑一下这些操作的复杂度。首先假设 `malloc` 有一个与之绑定的寄存器（`new-loc`），指向堆（`store`），每次分配内存的时候直接获取下一个可用地址。这个模型非常简单——事实上，只是看上去简单而已。当你尝试使用 `free` 释放它分配的内存时就会出现问题。如果每次调用的 `free` 都针对的是上一次 `malloc` 分配的内存，则没有任何问题；但是堆数据一般不遵从这种先进先出的规则。当我们释放的不是最新分配的内存，将会在堆中留下一个洞。这会导致碎片化（fragmentation），最坏的情况下，即使堆中存在足够的空余空间，也无法分配出整块的内存以创建一个对象。

**练习**
> 原则上我们可以通过使所有空余空间相邻来解决碎片化的问题，想象一下怎么达成这点？考虑这样做的后果然后想象一下是否可以手工实现这点。

大部分手工管理内存的方案中碎片化都是一个不可逾越的问题，在这个看上去很简单的方式还有一些东西值得考虑。使用 `free` 释放一块内存之后会发生什么？运行时系统需要通过某种方式记录这块内存已经空闲并可被分配，它是通过维护一个空闲空间的链表来达成这点的。稍作思考就会想到一个问题，该链表存在哪，它的内存管理又由谁来做呢？答案是这个空闲空间链表存放在空闲单元格里，这也意味着内存分配时存在一个最小分配单元。

原则上，每次 `malloc` 都需要遍历空闲列表以找到合适的位置。要找到“合适的”位置需要内存分配器做出一个相当复杂的决定。它是否应该直接在分配的第一个匹配的位置或者说还有其它考虑？而且“匹配”的位置又是怎么定义的呢？应该选取那些大小刚好的连续空间，还是将大些的连续空间打断（这会造成一些不可用的内存碎片）？还有其它诸多问题。

开发者希望内存分配高效，如果内存分配不够高效，开发者会尝试各种奇技赢巧来重用一些值，这会极大降低代码的清晰性，很有可能会导致错误。因此，实践中，分配系统倾向使用一组固定尺寸，一般是 2 的幂。这样我们可以为每个尺寸（这些尺寸是 2 的幂）维护一个链表。然后再维护一个指向这些链表的表，位操作可以使表的索引极快。当然，这样会浪费一些空间，因为当需要那些不是 2 的幂尺寸的内存时，最终分配给其的内存尾部将会有空余（这是计算机科学中一个经典的要做的权衡（trade-off）：内存换时间）。`free` 会将释放的内存放到合适的链表中，有时候甚至会将较大块的内存分割到不同大小的链表中以为将来的分配做准备。这个模型中的任何部分都不像看上去的那样高效【TODO:】。

> 比如说，`free` 并不是免费的（原文 `free is not free`，双关）。

Of course, all this assumes that developers can function in even a sound, much less complete, fashion. But they don’t【TODO:】.

### 11.3.2 引用计数（reference counting）

完全人工的方式进行内存回收给开发者带来极大的负担，一些半自动化技术很长期以来被大家使用，最为人知的便是**引用计数**。

使用引用计数的方式，每个值将关联一个对其引用个数的计数值。开发者负责维护该值的大小。当该计数值降为 0 时，该值的空间将被回收供将来使用。

很容易发现，上面的描述中隐藏了两个重要假设：

1. 开发者可以追踪每次引用。别名也是引用，因此，当写出下面的代码时，
    ```scheme
    (let ([x <some value>])
      (let ([y x])
        ..))
    ```
   开发者需要记住 `y` 是对 `x` 引用的那个值的第二次引用，因此要增加该值的引用计数。
2. 每个值只有有穷个引用。但是如果数据中存在环路，这条假设将不成立。

由于需要手工管理计数值，这种方式缺乏可靠性与完全性。上面的第二条假设直接导致的丧失，而第一条假设也指出了一种简单的打破可靠性的方法。

手工管理内存的弊端还可以更为深层隐晦。由于开发者负责释放内存（或者，等效的，管理引用计数），内存管理策略必须成为每个库接口的一部分：即，接口中需要提供类似“库中分配的值谁来释放？库会否释放传递给它的值？”这种问题的解答。很不幸，用文档准确记录这种策略信息极其困难，更糟的是，它会导致文档中充斥关于过多底层细节，它们通常与库要封装的行为本身并无关系。

一个有趣的想法是将计数值的增减自动化。另一个想法是在实现中添加循环检测（cycle-detection）。引入这两者将解决上面描述中的很多问题，但是引用计数还有一些其它问题：

* 引用计数器需要足够大以防止溢出，又要足够小以避免过多的内存占用。
* 这些计数器值的增减花费的时间将是可观的。
* 如果一个对象的引用计数值降至 0，那么它所引用的所有东西的计数值都需要减一，这种行为可能会是递归的。即一次释放操作可能会花费大量时间，除非使用聪明的“惰性（lazy）”技术（这样的话又会导致内存占用增加）。
* 减少计数值需要遍历那些已经是垃圾的对象。看上去有点奇怪，需要遍历那些我们已经不感兴趣的对象。工程实践中也会出现一些问题：这些我们不感兴趣的对象很有可能已经很久没有被访问过了，这意味着它们可能被换页换出内存了，引用计数器需要将它们换回内存，仅为了告诉它们它们不再被需要了。

出于这些原因，应谨慎引用计数。不应该将它作为你的默认选项，且在真的决定用它前需要权衡为什么不使用那些通常被认为更好的自动化的技术。

__思考题__
> 如果引用计数溢出了，哪些正确性被破坏，是怎么被破坏的？权衡利弊。

## 11.4 自动回收，或垃圾收集

下面简单检视一下编程语言运行时系统中垃圾自动回收的要点。我们将使用缩写 GC（Garbage Collection）指代垃圾回收的算法与回收的过程，上下文可以帮你区分具体指代哪个。

### 11.4.1 概览

所有 GC 算法的核心是通过值间引用关系遍历内存。遍历从一组根值开始，它们是程序中所有可能对堆上数据进行引用的值的集合。通常这个根值集合中包含了环境中绑定的变量以及所有全局变量。在实际实现中，还需要考虑到类似寄存器中的引用这种易逝值。从这一组根值开始，GC 算法使用各种算法（通常是深度优先搜索算法的变种）遍历所有的值以鉴别出所有“活”数据（例如通过特定程序序列将使用到）。按定义所有其它数据就是垃圾。不同算法将使用不同方式回收这些空间。

### 11.4.2 真理和可证性（Truth and Provability）

如果你读的仔细的话，你会发现上面的描述中引入了一个算法。这是实现细节，而不是规范！垃圾回收的规范是一组表述真理的术语：垃圾回收要精确的回收所有是且仅是垃圾的值。我们不能从任何图灵完全的编程语言中得出真理，我们需要解决可证性的问题。上面这种通过算法描述垃圾的补集的方式给出了垃圾回收可行性的一个有效“证明”。这种方式还有很多不同变种，它们可能收集更多或更少的垃圾，取决于我们我们在何种程度上认定一个值是垃圾。

上面的说的最后一点也指出了严格规范术语描述中的一个缺陷，对于要回收多少垃圾它完全没有说明。考虑一下极端情况实际上极其有益。

__思考题__
> 定义一个 sound 的垃圾回收策略很简单，对应的，定义一个 complete 的垃圾回收策略也非常简单，你能想到怎么做吗？

要做到 sound，我们只要确保不会错误的移除任何可能是“活”的数据，一种确保无疑的方式就是不回收任何垃圾。与之对应，回收所有东西我们将达成 complete。显然这两者都是无用的（后者显然极其危险）。这为我们的工程实践指明了一点，我们不仅希望 GC 是 sound 的，也需要它足够 complete ，同时还要足够高效。

### 11.4.3 核心假设

能够可靠地执行 GC 依赖于两条核心假设，第一条有关语言实现，另一条有关语言语义。

1. 面对一个值时，GC 需要知道该值的类型以及它在内存中的表示，例如，当遍历到一个 `cons` 单元，它必须知道：
  1. 这是一个 `cons` 单元；因此，
  2. 其 `first` 是，例如按实现有4个字节的偏移，
  3. 其 `rest` 是，例如按实现有8个字节的偏移。

  显然，这条假设中必须内含递归，使得遍历程序能够正确映射内存中的值。
2. 程序不能通过下面两种方式产生引用：
  1. 对象引用不能发生在实现预定义的根值集合外
  2. 对象引用只能指向对象中定义良好的点

  违反第二条时，GC 将完全乱套，错误的解释数据。第一条看上去显而易见，如果它被违反，意味着运行时系统已经错误理解语言的语义。然而这条的后果有点微妙，下面将会讨论。

## 11.5 保守（conservative）的垃圾回收

上文说过，一般根值集合包含环境、全局变量和一些易逝值。引用还可能出现在什么地方？

大部分语言中，不会出现在其他地方了。但是有些语言（说的就是你们，C 和 C++）允许将引用转换成数，以及将数转换成引用。这意味着程序中任何数值（由于 C 和 C++ 类型系统的特性，可能程序中所有的值都能转换为数）都可能潜在的被当作引用。

两个原因使得它问题重重。首先，GC 不能只将其注意力集中在一个较小的根值集合中；现在整个堆都是潜在的根值。其次，如果 GC 试图以任何方式修改一个对象——如遍历时记录一个“访问”位——这时它可能修改了一个非引用值：如，改变了程序中某个数值常量。

但也不是不可能，一个令人兴奋的研究方向——称为保守 GC ——成功的为此类语言创建了足够高效的垃圾回收系统。保守 GC 认定的一项基本原则是尽管理论上每个堆地址都可能属于根值集合，但实际中它们大部分都不是的。它会通过一系列聪明的观察来推断出哪些位置肯定不是引用（这点和传统 GC 不同），然后将它们忽略掉：例如，在一个字节对其的体系架构中，奇数值不可能为引用。根据程序行为作出一些假定（例如程序不可能产生特定种类的引用）后排除掉堆中大部分位置后，在足够谨慎、不去修改堆（例如，改变值中的比特或者移动数据）的情况下，可以得到一个足够高效的 GC 策略。

保守 GC 在那些使用 C 和 C++ 实现或者 code base 依赖它们的语言中比较常见。例如 Racket 早期就完全依靠它。这种情形有以下原因：

1. 它是一种便捷的自举技术，语言实现者因此能够将精力集中在其它更富革新性的特性上。
2. 一门控制了所有引用的语言（如 Racket）可以很容易的创建便于增加 GC 效率的内存表示（TODO:）
3. 它使得和 C 及 C++ 写的库进行互操作很简单（当然前提是他们也符合该技术的期望）。

如前所述，所有工程实现中的 GC 在尽可能达成其真理性定义这一点上去看的话，都可以被认为是“保守的”。然而，现在“保守”一词现在已经成为指代可以在非合作（uncooperative）运行时系统中工作的 GC 技术的专门术语了。

## 11.6 精确（precise）垃圾回收

通常的 GC 术语上下文中，“保守”的反义词是精确。这也是一个不恰当的表述，因为 GC 不可能做到精确，如同时达成可靠性和完全性。这里精确更多是对 GC 识别引用的能力的表述：面对一个值时，一个精确的 GC 知道它是不是一个引用，如果是，可以得知引用的指向。这大大减轻保守 GC 对于值是否是引用的判断这项繁重的工作（理想情况下，这个过程还可以排除掉很多潜在的引用）。

在精确 GC 的世界里——这也是大部分现代的语言运行时使用的——存在大量的实现技巧。我推荐 [Paul Wilson 的研究](ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps)（虽然该领域非常活跃，日新月异，但是这份有点显老的材料仍是很好的资源）和 [Richard Jones](https://www.cs.kent.ac.uk/people/staff/rej/gc.html) 的书和材料。最后，要对获取各代垃圾回收器有个快速总览可以读一下[Simple Generational Garbage Collection and Fast Allocation](http://www.cs.princeton.edu/~appel/papers/143.ps)。
