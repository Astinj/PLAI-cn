# 11 内存管理

## 11.1 垃圾

我们使用**垃圾（Garbage）**指代那些被分配但是不在被需要的内存。编程语言的运行时系统中有两类典型的内存分配方式。一种是环境：使用堆栈结构存放静态作用域相关信息，函数调用返回时，直接释放为其分配的环境内存，不需要考虑太多。与之相对的，堆上分配的内存需要追踪值生命周期，它可能在创建其的作用域外面仍然存活——而且有可能会一直存在。因此对于堆上分配的内存产生的垃圾需要采取一些不同的策略。

内存回收方式有很多种，可以分到两个阵营中：人工和自动。人工的方式依赖于开发者去跟踪内存使用，回收不需要的内存。一般认为，人并不擅长做这种事。因此，几十年来，自动化的方法已经变得几乎无处不在。

## 11.2 什么样的垃圾回收是“正确的”？

垃圾回收进行的既不能过早（soundness）也不能太迟（completeness）。两种情况都被认为是有问题的，但是它们造成的影响程度不同：过早的垃圾回收糟糕得多。这是因为如果过早回收了栈上内存，后续程序继续再该内存上进行读写，而这已经是无意义的。它会导致程序不正确，极端情况下，可能会产生安全问题。与之相对的，过迟的垃圾回收会导致性能损失，并且有可能最终因为缺少内存导致程序终止，尽管理论上存在可用内存（只是还没有被回收）。这种性能上的损失以及可能的被迫终止也许很烦人，是在运行着关键任务的系统中这可能会个重大问题，但是至少程序没有在一块被回收的内存上进行着无意义的运算。

理想的情况是我们能够拥有所有的这三个特性：自动化（automation），soundness，completeness。然而，这里我们面对的是不可兼得的情形，必须要进行权衡。理想情况下人能够既实现 soundness 同时实现 completeness，但实践中实现其中任意一个都很少见。计算机自动化过程可以提供 soundness 和 completeness 中的一个，可计算性论证表明，它们两个不能同时达成这两者。实践中，自动化技术一般选择实现 soundness，出于一下原因：（a）它造成的损害相对小，（b）相对更容易实现，（c）且在添加一些人工干预的情况下，可以非常接近 completeness。

## 11.3 人工回收

最人工的方式是将所有内存的回收交由人进行。例如，在 C 语言中提供了两个基本操作：`malloc` 用于分配内存，`free` 用于释放内存。`malloc` 接收要分配内存的容量为参数，返回一个对分配了的栈上值的引用；`free` 接收引用作为参数，释放引用关联的内存。

### 11.3.1 完全人工内存回收的代价

首先考虑一下这些操作的复杂度。首先假设 `malloc` 有一个与之绑定的寄存器（`new-loc`），指向堆（`store`），每次分配内存的时候直接获取下一个可用地址。这个模型非常简单——事实上，只是看上去简单而已。当你尝试使用 `free` 释放它分配的内存时就会出现问题。如果每次调用的 `free` 都针对的是上一次 `malloc` 分配的内存，则没有任何问题；但是堆数据一般不遵从这种先进先出的规则。当我们释放的不是最新分配的内存，将会在堆中留下一个洞。这会导致碎片化（fragmentation），最坏的情况下，即使堆中存在足够的空余空间，也无法分配出整块的内存以创建一个对象。

**练习**
> 原则上我们可以通过使所有空余空间相邻来解决碎片化的问题，这样做需要什么？考虑这样做的后果然后想象一下是否可以手工实现这点。

