# 11 内存管理

## 11.1 垃圾

我们使用**垃圾（Garbage）**指代那些被分配但是不在被需要的内存。编程语言的运行时系统中有两类典型的内存分配方式。一种是环境：使用堆栈结构存放静态作用域相关信息，函数调用返回时，直接释放为其分配的环境内存，不需要考虑太多。与之相对的，堆上分配的内存需要追踪值生命周期，它可能在创建其的作用域外面仍然存活——而且有可能会一直存在。因此对于堆上分配的内存产生的垃圾需要采取一些不同的策略。

内存回收方式有很多种，可以分到两个阵营中：人工和自动。人工的方式依赖于开发者去跟踪内存使用，回收不需要的内存。一般认为，人并不擅长做这种事。因此，几十年来，自动化的方法已经变得几乎无处不在。

## 11.2 什么样的垃圾回收是“正确的”？

垃圾回收进行的既不能过早（soundness）也不能太迟（completeness）。两种情况都被认为是有问题的，但是它们造成的影响程度不同：过早的垃圾回收糟糕得多。这是因为如果过早回收了栈上内存，后续程序继续再该内存上进行读写，而这已经是无意义的。它会导致程序不正确，极端情况下，可能会产生安全问题。与之相对的，过迟的垃圾回收会导致性能损失，并且有可能最终因为缺少内存导致程序终止，尽管理论上存在可用内存（只是还没有被回收）。这种性能上的损失以及可能的被迫终止也许很烦人，是在运行着关键任务的系统中这可能会个重大问题，但是至少程序没有在一块被回收的内存上进行着无意义的运算。

理想的情况是我们能够拥有所有的这三个特性：自动化（automation），soundness，completeness。然而，这里我们面对的是不可兼得的情形，必须要进行权衡。理想情况下人能够既实现 soundness 同时实现 completeness，但实践中实现其中任意一个都很少见。计算机自动化过程可以提供 soundness 和 completeness 中的一个，可计算性论证表明，它们两个不能同时达成这两者。实践中，自动化技术一般选择实现 soundness，出于一下原因：（a）它造成的损害相对小，（b）相对更容易实现，（c）且在添加一些人工干预的情况下，可以非常接近 completeness。

## 11.3 人工回收

最人工的方式是将所有内存的回收交由人进行。例如，在 C 语言中提供了两个基本操作：`malloc` 用于分配内存，`free` 用于释放内存。`malloc` 接收要分配内存的容量为参数，返回一个对分配了的栈上值的引用；`free` 接收引用作为参数，释放引用关联的内存。

### 11.3.1 完全人工内存回收的代价

首先考虑一下这些操作的复杂度。首先假设 `malloc` 有一个与之绑定的寄存器（`new-loc`），指向堆（`store`），每次分配内存的时候直接获取下一个可用地址。这个模型非常简单——事实上，只是看上去简单而已。当你尝试使用 `free` 释放它分配的内存时就会出现问题。如果每次调用的 `free` 都针对的是上一次 `malloc` 分配的内存，则没有任何问题；但是堆数据一般不遵从这种先进先出的规则。当我们释放的不是最新分配的内存，将会在堆中留下一个洞。这会导致碎片化（fragmentation），最坏的情况下，即使堆中存在足够的空余空间，也无法分配出整块的内存以创建一个对象。

**练习**
> 原则上我们可以通过使所有空余空间相邻来解决碎片化的问题，这样做需要什么？考虑这样做的后果然后想象一下是否可以手工实现这点。

在大部分手工管理内存的方案中碎片化是一个不可逾越的问题。使用 `free` 释放一块内存之后会发生什么？运行时系统需要通过某种方式记录这块内存已经空闲并可被分配，它是通过维护一个空闲空间的链表来达成这点的。思考一下会发现一个问题，该链表存在哪，它的内存管理又由谁来做呢？答案是这个空闲空间链表存放在空闲单元格里，分配内存时会有一个最小分配单元。

原则上，每次 `malloc` 都需要遍历空闲列表找到合适的位置然后分配内存。要找到“合适的”位置需要内存分配器做出一个相当复杂的决定。它是否应该直接在找到的第一个匹配的位置分配内存？“匹配”的位置指的是什么意思？应该选取那些大小刚好的连续空间，还是将大些的连续空间打断（这会造成一些不可用的内存碎片）？还有其它诸多问题。

开发者希望内存分配要快。因此，实践中，分配系统倾向使用一组固定尺寸，一般是 2 的幂。这样我们为每个尺寸（这些尺寸是 2 的幂）维护一个链表而不是一个。然后再维护一个指向这些链表的表，通过位操作可以使表的索引极快。当然，这样会浪费一些空间，因为当需要那些不是 2 的幂尺寸的内存时，最终分配给其的内存尾部将会有空余（这是计算机科学中一个经典的 trade-off：内存换时间）。`free` 会将释放的内存放到合适的链表中，有时候甚至会将较大块的内存分割到不同大小的链表中以为将来的分配做准备。Nothing about this model is inherently as cheap as it seems.

> 如果内存分配不够快的话，开发者会使用一些怪招来重用值，这样会导致代码变得不清晰，并可能产生错误。

Of course, all this assumes that developers can function in even a sound, much less complete, fashion. But they don’t.

### 11.3.2 引用计数

完全人工的方式进行内存回收给开发者带来极大的负担，一些半自动化技术很长期以来被大家使用，最为人知的便是**引用计数（reference counting）**。

使用引用计数的方式，每个值将关联一个对其引用个数的计数值。开发者负责该值的递增与递减。当该计数值降为 0 时，该值的空间将被回收供将来使用。

很容易发现，上面的描述中隐藏了两个重要假设：

1. 开发者可以追踪每次引用。别名也是引用，因此，当写出下面的代码时，
    ```
    (let ([x <some value>])
      (let ([y x])
        ..))
    ```
    开发者需要记住 `y` 是对 `x` 引用的那个值的第二次引用，因此要增加引用计数器。
2. 每个值只有有穷个引用。但是如果数据中存在环路，这条假设将不成立。

由于需要手工管理计数值，这种方式缺乏 `soundness` 和 `completeness` 特性。上面的第二条假设直接导致 `completeness` 的丧失，而第二条假设也直接指向打破 `soundness` 的最简单的方法。

手工管理内存的弊端还可以更为深层隐晦。由于开发者负责释放内存（或者，等效的，管理引用计数），内存管理策略必须成为每个库接口的一部分：即，接口中需要提供类似“库中分配的值谁来释放？库会否释放传递给它的值？”这种问题的答案。很不幸，用文档准确记录这种策略信息极其困难，更糟的是，它会导致文档中充斥关于库实现的过于底层的东西。

一个有趣的想法是将计数值的增减自动化。另一个想法是在实现中添加循环检测（cycle-detection）。引入这两者将解决上面描述中的很多问题，但是引用计数还有一些其它问题：

* 引用计数器需要足够大以防止溢出，又要足够小以避免过多的内存占用。
* 这些计数器值的增减花费的时间可能是可观的。
* 如果一个对象的引用计数值降至 0，那么它所引用的所有东西的计数值都需要减一，这种行为可能会是递归的。即一次释放操作可能会花费大量时间，除非使用聪明的“惰性（lazy）”技术（这样的话又会导致内存占用增加）。
* 减少计数值需要遍历那些已经是垃圾的对象。这看上去很有问题，遍历那些我们已经不感兴趣的对象。它会招致一些实践上的问题：这些我们不感兴趣的对象很有可能已经很久没有被访问过了，这意味着它们可能被换页换出内存了，引用计数器需要将它们换回内存，仅为了告诉它们它们不再被需要了。

出于这些原因，应谨慎引用计数。不应该将它作为你的默认选项，but rather ask yourself why it is you reject what are generally better automated techniques.

**练习**
> 如果引用计数溢出了，哪些正确性被破坏，是怎么被破坏的？权衡利弊。

## 11.4 自动回收，或垃圾收集

下面简单监视一下编程语言运行时系统中自动垃圾回收的要点。我们使用缩写 GC（Garbage Collection）指代垃圾回收的算法与回收的过程。

### 11.4.1 概览

GC 算法的核心是通过值间引用关系遍历内存。
