# 17 其他调用语义

很久以前，我们讨论过在执行函数调用时替换的问题。现在是时候考虑一些替代方案了。当时，我们只提出了一种方案；其实还有更多选择。要理解这一点，请试着回答这个问题：

__下列哪些是相同的？__

* `(f x (current-seconds))`
* `(f x (current-seconds))`
* `(f x (current-seconds))`
* `(f x (current-seconds))`

我们将会发现，这段语法可以对应非常不同的运行时行为。比如我们提到过的区别：不同时间求值`(current-seconds)`的不同。另一个不同是，求值的**次数有多少**（因此`f`运行的次数有多少）。还有一个不同，`x`的值是严格从调用者流向被调用者，还是甚至可能以相反的方向流动！

## 17.1 惰性调用

先来考虑参数何时规约为值。即，我们是将形参替换为实参的**值**呢，还是实参**表达式**本身？如果我们定义

```Racket
(define (sq x) (* x x))
```

然后这样调用

```Racket
(sq (+ 2 3))
```

它是规约为

```Racket
(* 5 5)
```

呢，还是

```Racket
(* (+ 2 3) (+ 2 3))
```

？前者被称为**及早**（eager）调用，后者则被称为**惰性**（lazy）调用。【注释】当然，我们不想回到替换模型来定义解释器，但将替换视为设计原则总是有用的。

> 有些人将前者称为**严格**的（strict）。更加晦涩难解的术语将前者称为**调用次序求值**（applicative-order evaluation），后者称为**正常次序求值**（normal-order evaluation）。还有，前者称为**传值调用**（call-by-value），后者称为**传名调用**（call-by-name）或**传需求调用**（call-by-need）。最后这两个术语——传名和传需求——实际技术上有区别，我们将在后文讨论。关于名字的介绍就到这里。

### 17.1.1 惰性调用示例

惰性这一选择有着辉煌的历史（例如，纯正的λ演算就用它），但淡出了编程实践，(初译意义存疑请校对)问题在于，某些运算符不在调用时对参数求值，而只当需要其值时才求值。例如，考虑定义

```Racket
(define ones (cons 1 ones))
```

在标准Racket中，这显然是有问题的：（左侧的）`ones`还没有完成定义，我们就（在右侧）尝试对它求值，所以这会导致错误。但是，如果我们不直接对它求值，直到我们真正需要它时，那么这个定义就成立了。因为每次`rest`操作都会获得另一个`ones`，我们得到了一个无穷列表。

我们略过了很多需要解释的地方。`cons`的`rest`位置求值得到的是`ones`的**副本**呢，还是原表达式本身呢？换句话说，我们是简单地创建了无限展开的列表，还是创建了实际上**循环的**列表？

这很大程度上取决于我们的语言是否带有赋值。如果有赋值，那么也许我们可以修改结果列表中的每个单元格，这意味着我们可以观察上述两个实现之间的区别：在展开版本中，修改一个`first`不会影响另一个，而在循环版本中，更改一个`first`会影响所有其他。因此，在有赋值的语言中，我们可能会倾向与惰性展开，而不是循环数据。

请记住这里的讨论。我们现在无法解决问题；所以我们先仔细检查一下惰性求值，然后回到这个问题。

### 17.1.2 什么是值？

回到之前的核心高阶函数解释器，我们记得有两种类型的值：数和闭包。要支持惰性求值，我们要问，在函数调用中怎么处理。究竟传入什么？

这似乎很明显：在惰性调用语义中，我们需要传入**表达式**。但细想就有问题了。表达式中包含标识符名称，【注释】而我们不希望它们被意外地绑定。

> 现在，它们真的是**标识符**而不是**变量**，我们马上会发现。

例如，假设我们有

```Racket
(define (f x)
  (lambda (y)
    (+ x y)))
```

这样调用它：

```Racket
((f 3) (+ x 4))
```

__思考题__
> 这应该返回什么？

显然，应该得到错误，报告x没有被绑定。

现在来逐步分析。第一步调用创建闭包，其中`x`绑定到`3`。如果接下来将`y`绑定到`(+ x 4)`，于是得到表达式`(+ x (+ x 4))`，而其环境中`x`是绑定的。因此我们得到答案`10`，而不是错误。

__思考题__
> 我们这里做了什么微妙的假设吗？

是的，我们有：我们假定`+`会对参数求值并返回数作为答案。也许`+`也可以是惰性的；我们稍后研究这个问题。不管怎么说，重点不变：如果我们不小心的话，这个错误的表达会得到某种合法的答案，而不是错误。

如果您认为这问题只关于错误的程序，因此可以专门处理（例如，先扫描程序源寻找自由标识符），下面是同一个`f`的另一个的用法：

```Racket
(let ([x 5])
  ((f 3) x))
```

__思考题__
> 这应该返回什么？

正常来说这应该求得`(+ 3 5)`的结果（即`8`）。但是，如果我们在算术表达式中替换`x`，我们会得到`(+ 3 3)`。

后面这个例子提示了解决方案的关键所在。在这个例子中，只有当我们用到环境时，问题才会出现；反之如果我们使用替换，一遇到`let`就替换函数调用中的`x`，结果就符合期望。事实上，请注意，这个观点对前一个例子也适用：如果我们使用替换，那么`x`的出现就导致错误。简而言之，我们必须确保基于环境的实现能匹配替换所能做到的。听起来熟悉不！

换种说法，解决方案是将参数表达式**与其环境捆绑在一起**：即创建闭包。此闭包没有参数，所以它实际上是**thunk（译注，无参数的lambda）**。【注释】我们可以使用已有的函数来表示这里的thunk，但是直觉告诉我们，更好的做法是为逻辑上不同的目的使用不同的数据表示：`closV`表示用户创建的闭包，用另一种东西表示内部创建的闭包。事实上，正如我们将看到的那样，将它们分开是明智的做法，因为有一个地方我们需要能将它们区分开来。

> 事实上，这表明函数有两个用途：用值替换名称，推迟替换。`let`只有前一个功能而没有后一个；thunk只有后一个功能而没有前一个。前文已经明确，前者本身是有意义的；本节表明后者也是如此。

总结来说，现在我们新的值的集合是：

```Racket
(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)]
  [suspendV (body : ExprC) (env : Env)])
```

前两个变体完全不变；第三个是新的，正如我们所讨论的，它实际上是一个无参数的子程序，正如其类型所暗示的那样。

### 17.1.3 何时求值？

回头来讨论算术表达式。对`(+ 1 2)`求值时，惰性调用的解释器可以返回好几种东西，包括`(suspendV (+ 1 2) mt-env)`。【注释】通过这种方式，挂起的计算可以串上挂起的计算，在极限情况下，任何程序都会立即返回“答案”：表示暂停计算的thunk。

> 这里放上`mt-env`（译注，空白环境）是合理的，因为就算`(+ 1 2)`表达式存在与非空的环境中，它其中也不包含自有标识符，因此不需要任何环境的绑定。

显然，必须**有啥东西**来强制解除暂停。（当然，解除暂停的意思是，在存储下来的环境中对主体求值。）这种解除表达式暂停的位置称为**严格点（strictness point）**。最明显的严格点是交互式环境的打印，因为如果用户使用交互环境显然是希望看到答案。我们用`strict`子程序表示解除暂停：

```Racket
(define (strict [v : Value]) : Value
  (type-case Value v
    [numV (n) v]
    [closV (a b e) v]
    [suspendV (b e) (strict (interp b e))]))
```

这里返回的`Value`保证不是`suspendV`。我们可以假设打印程序会对被求值的表达式调用`strict`，以获得要打印的值。

__思考题__
> 如果使用闭包来表示暂停计算，后果是啥？

这个`strict`定义依赖于区分延迟计算的能力——哪些是内部构建的闭包，哪些是用户定义的闭包。如果我们将两者混为一谈，那么这里就不得不猜测如何处理零参数闭包。如果没有进一步处理它们，我们可能会错误地得到报错（例如，`+`可能会得到thunk而不是其中的数值）。如果进一步处理，我们可能会意外地过早调用用户定义的thunk。总之，对于thunk我们需要一个标志，告诉我们它们是内部的还是用户定义的。为了清晰起见，我们的解释器使用独立的变体。

接下来讨论`strict`和解释器之间的互动。不幸的是，按我们原来的定义，这将导致无限循环。要解释加法，需要先创建暂停，`strict`会试图解除暂停，这需要用解释器来解释加法，而这又……显然，我们不能让每个表达式都简单的暂停计算；相反，我们只暂停函数调用。这不会使语言变得荒谬，又足以让我们拥有惰性求值的强大力量。

### 17.1.4 解释器

照例，我们将分步定义解释器。

```Racket
<lazy-interp> ::=

    (define (interp [expr : ExprC] [env : Env]) : Value
      (type-case ExprC expr
        <lazy-numC-case>
        <lazy-idC-case>
        <lazy-plusC/multC-case>
        <lazy-appC-case>
        <lazy-lamC-case>))
```

数很容易：它们已经是值了，所以没必要暂停它们：

```Racket
<lazy-numC-case> ::=

    [numC (n) (numV n)]
```

闭包同样保持不变：

```Racket
<lazy-lamC-case> ::=

    [lamC (a b) (closV a b env)]
```

标识符应该返回它们所绑定的内容：

```Racket
<lazy-idC-case> ::=

    [idC (n) (lookup n env)]
```

算术表达式的参数通常被定义为严格点，不然的话我们会不得不在其他地方实现实际的算术运算：

```Racket
<lazy-plusC/multC-case> ::=

    [plusC (l r) (num+ (strict (interp l env))
                       (strict (interp r env)))]
    [multC (l r) (num* (strict (interp l env))
                       (strict (interp r env)))]
```

最后我们要处理函数调用。在这里，我们不再对参数求值，而是将其暂停。然而，函数位置必须是严格点，否则我们不知道要调用什么函数，也就不知道如何继续计算：

```Racket
<lazy-appC-case> ::=

    [appC (f a) (local ([define f-value (strict (interp f env))])
                  (interp (closV-body f-value)
                            (extend-env (bind (closV-arg f-value)
                                              (suspendV a env))
                                        (closV-env f-value))))]
```

这就行了！添加一种新的答案、插入一些`strict`、并在函数调用参数位置用`suspendV`替换`interp`，我们就将及早调用解释器转换成了惰性调用了。然而，这个小小的变化对我们编写的程序有着巨大的影响！要更全面地了解这种影响，请学习Haskell或Racket中的`#lang lazy`语言。

__练习__
> 如果我们把标识符子句替换为`(strict (lookup n env))`（即对查找标识符的结果调用`strict`），会对语言产生什么影响？请考虑更丰富的语言的情况，比如包含数据结构的情况。

__练习__
> 编写一些程序，它们在惰性求值下会给出和及早求值不同的结果（在两种情况下，同样的程序给出不同的结果）。请给出有意义的差异，一个返回`suspendV`而另一个不不算。比如说，一个会终止而另一个不会，或者一个会产生错误而另一个不会？

__练习__
> 调整两个解释器，让它们记录求得答案的步数。对于在两种求值策略下产生相同答案的程序，一个策略是否总是比另一个需要更多步骤？

### 17.1.5 惰性和赋值

惰性求值的优点之一是它会延迟执行。通常这是好事：它使我们能够构建无限的数据结构，还能避免不必要的计算。不幸的是，它也改变了计算发生的时间，尤其是表达式求值的相对时间，这取决于何时遇到严格点。结果是，程序员基本无法预测计算的顺序。当表达式执行赋值操作时，这显然是个问题，因为现在要预测程序将计算出什么值变得非常困难（相对及早求值来说）。

这导致了，所有惰性语言的核心中都不支持赋值。在Haskell中，赋值和其他状态操作都通过**monad（单子）**和**arrow（箭头）**等多种机制，引入了（严格）序列化代码的能力后再引入；这种顺序性对于能够预测执行顺序以及操作结果至关重要。如果程序结构良好，这些依赖关系的数量应该很小；此外，Haskell类型系统试图在类型本身中反映这些操作，因此程序员可以更轻松地推理其效果。

### 17.1.6 缓存计算结果

既然已经得出结论，惰性计算必须不包含赋值，我们观察到一个令人愉快的结果（能不能称其为副作用呢？）：给定固定的环境，同一表达式总会产生相同的答案。其结果是，当表达式第一次被严格求值时，运行时系统可以缓存其值，并在随后计算它时返回这个缓存值。当然，这种缓存（这是**记忆化**(memoization)的一种形式）只有当表达式每次返回相同的值时才成立，这正是我们所假设的。实际上，编译器和运行时系统可以积极地在程序的不同部分中使用相同的表达式，并且如果其环境的相关部分相同，则合并求值。每当需要被暂停的计算时都求值的策略称为**传名调用**；将结果缓存起来，则称为**传需求调用**。
