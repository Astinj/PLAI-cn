# 17 其他调用语义

很久以前，我们讨论过在执行函数调用时替换的问题。现在是时候考虑一些替代方案了。当时，我们只提出了一种方案；其实还有更多选择。要理解这一点，请试着回答这个问题：

__下列哪些是相同的？__

* `(f x (current-seconds))`
* `(f x (current-seconds))`
* `(f x (current-seconds))`
* `(f x (current-seconds))`

我们将会发现，这段语法可以对应非常不同的运行时行为。比如我们提到过的区别：不同时间求值`(current-seconds)`的不同。另一个不同是，求值的**次数有多少**（因此`f`运行的次数有多少）。还有一个不同，`x`的值是严格从调用者流向被调用者，还是甚至可能以相反的方向流动！

## 17.1 惰性调用

先来考虑参数何时规约为值。即，我们是将形参替换为实参的**值**呢，还是实参**表达式**本身？如果我们定义

```Racket
(define (sq x) (* x x))
```

然后这样调用

```Racket
(sq (+ 2 3))
```

它是规约为

```Racket
(* 5 5)
```

呢，还是

```Racket
(* (+ 2 3) (+ 2 3))
```

？前者被称为**及早**（eager）调用，后者则被称为**惰性**（lazy）调用。【注释】当然，我们不想回到替换模型来定义解释器，但将替换视为设计原则总是有用的。

> 有些人将前者称为**严格**的（strict）。更加晦涩难解的术语将前者称为**调用次序求值**（applicative-order evaluation），后者称为**正常次序求值**（normal-order evaluation）。还有，前者称为**传值调用**（call-by-value），后者称为**传名调用**（call-by-name）或**传需求调用**（call-by-need）。最后这两个术语——传名和传需求——实际技术上有区别，我们将在后文讨论。关于名字的介绍就到这里。

### 17.1.1 惰性调用示例

惰性这一选择有着辉煌的历史（例如，纯正的λ演算就用它），但淡出了编程实践，(初译意义存疑请校对)问题在于，某些运算符不在调用时对参数求值，而只当需要其值时才求值。例如，考虑定义

```Racket
(define ones (cons 1 ones))
```

在标准Racket中，这显然是有问题的：（左侧的）`ones`还没有完成定义，我们就（在右侧）尝试对它求值，所以这会导致错误。但是，如果我们不直接对它求值，直到我们真正需要它时，那么这个定义就成立了。因为每次`rest`操作都会获得另一个`ones`，我们得到了一个无穷列表。

我们略过了很多需要解释的地方。`cons`的`rest`位置求值得到的是`ones`的**副本**呢，还是原表达式本身呢？换句话说，我们是简单地创建了无限展开的列表，还是创建了实际上**循环的**列表？

这很大程度上取决于我们的语言是否带有赋值。如果有赋值，那么也许我们可以修改结果列表中的每个单元格，这意味着我们可以观察上述两个实现之间的区别：在展开版本中，修改一个`first`不会影响另一个，而在循环版本中，更改一个`first`会影响所有其他。因此，在有赋值的语言中，我们可能会倾向与惰性展开，而不是循环数据。

请记住这里的讨论。我们现在无法解决问题；所以我们先仔细检查一下惰性求值，然后回到这个问题。

### 17.1.2 什么是值？

回到之前的核心高阶函数解释器，我们记得有两种类型的值：数和闭包。要支持惰性求值，我们要问，在函数调用中怎么处理。究竟传入什么？

这似乎很明显：在惰性调用语义中，我们需要传入**表达式**。但细想就有问题了。表达式中包含标识符名称，【注释】而我们不希望它们被意外地绑定。

> 现在，它们真的是**标识符**而不是**变量**，我们马上会发现。

例如，假设我们有

```Racket
(define (f x)
  (lambda (y)
    (+ x y)))
```

这样调用它：

```Racket
((f 3) (+ x 4))
```

__思考题__
> 这应该返回什么？

显然，应该得到错误，报告x没有被绑定。

现在来逐步分析。第一步调用创建闭包，其中`x`绑定到`3`。如果接下来将`y`绑定到`(+ x 4)`，于是得到表达式`(+ x (+ x 4))`，而其环境中`x`是绑定的。因此我们得到答案`10`，而不是错误。

__思考题__
> 我们这里做了什么微妙的假设吗？

是的，我们有：我们假定`+`会对参数求值并返回数作为答案。也许`+`也可以是惰性的；我们稍后研究这个问题。不管怎么说，重点不变：如果我们不小心的话，这个错误的表达会得到某种合法的答案，而不是错误。

如果您认为这问题只关于错误的程序，因此可以专门处理（例如，先扫描程序源寻找自由标识符），下面是同一个`f`的另一个的用法：

```Racket
(let ([x 5])
  ((f 3) x))
```

__思考题__
> 这应该返回什么？

正常来说这应该求得`(+ 3 5)`的结果（即`8`）。但是，如果我们在算术表达式中替换`x`，我们会得到`(+ 3 3)`。

后面这个例子提示了解决方案的关键所在。在这个例子中，只有当我们用到环境时，问题才会出现；反之如果我们使用替换，一遇到`let`就替换函数调用中的`x`，结果就符合期望。事实上，请注意，这个观点对前一个例子也适用：如果我们使用替换，那么`x`的出现就导致错误。简而言之，我们必须确保基于环境的实现能匹配替换所能做到的。听起来熟悉不！

换种说法，解决方案是将参数表达式**与其环境捆绑在一起**：即创建闭包。此闭包没有参数，所以它实际上是**thunk（译注，无参数的lambda）**。【注释】我们可以使用已有的函数来表示这里的thunk，但是直觉告诉我们，更好的做法是为逻辑上不同的目的使用不同的数据表示：`closV`表示用户创建的闭包，用另一种东西表示内部创建的闭包。事实上，正如我们将看到的那样，将它们分开是明智的做法，因为有一个地方我们需要能将它们区分开来。

> 事实上，这表明函数有两个用途：用值替换名称，推迟替换。`let`只有前一个功能而没有后一个；thunk只有后一个功能而没有前一个。前文已经明确，前者本身是有意义的；本节表明后者也是如此。

总结来说，现在我们新的值的集合是：

```Racket
(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)]
  [suspendV (body : ExprC) (env : Env)])
```

前两个变体完全不变；第三个是新的，正如我们所讨论的，它实际上是一个无参数的子程序，正如其类型所暗示的那样。

### 17.1.3 何时求值？

回头来讨论算术表达式。对`(+ 1 2)`求值时，惰性调用的解释器可以返回好几种东西，包括`(suspendV (+ 1 2) mt-env)`。【注释】通过这种方式，挂起的计算可以串上挂起的计算，在极限情况下，任何程序都会立即返回“答案”：表示暂停计算的thunk。

> 这里放上`mt-env`（译注，空白环境）是合理的，因为就算`(+ 1 2)`表达式存在与非空的环境中，它其中也不包含自有标识符，因此不需要任何环境的绑定。

显然，必须**有啥东西**来强制解除暂停。（当然，解除暂停的意思是，在存储下来的环境中对主体求值。）这种解除表达式暂停的位置称为**严格点（strictness point）**。最明显的严格点是交互式环境的打印，因为如果用户使用交互环境显然是希望看到答案。我们用`strict`子程序表示解除暂停：

```Racket
(define (strict [v : Value]) : Value
  (type-case Value v
    [numV (n) v]
    [closV (a b e) v]
    [suspendV (b e) (strict (interp b e))]))
```

这里返回的`Value`保证不是`suspendV`。我们可以假设打印程序会对被求值的表达式调用`strict`，以获得要打印的值。

__思考题__
> 如果使用闭包来表示暂停计算，后果是啥？

这个`strict`定义依赖于区分延迟计算的能力——哪些是内部构建的闭包，哪些是用户定义的闭包。如果我们将两者混为一谈，那么这里就不得不猜测如何处理零参数闭包。如果没有进一步处理它们，我们可能会错误地得到报错（例如，`+`可能会得到thunk而不是其中的数值）。如果进一步处理，我们可能会意外地过早调用用户定义的thunk。总之，对于thunk我们需要一个标志，告诉我们它们是内部的还是用户定义的。为了清晰起见，我们的解释器使用独立的变体。

接下来讨论`strict`和解释器之间的互动。不幸的是，按我们原来的定义，这将导致无限循环。要解释加法，需要先创建暂停，`strict`会试图解除暂停，这需要用解释器来解释加法，而这又……显然，我们不能让每个表达式都简单的暂停计算；相反，我们只暂停函数调用。这不会使语言变得荒谬，又足以让我们拥有惰性求值的强大力量。

### 17.1.4 解释器

照例，我们将分步定义解释器。

```Racket
<lazy-interp> ::=

    (define (interp [expr : ExprC] [env : Env]) : Value
      (type-case ExprC expr
        <lazy-numC-case>
        <lazy-idC-case>
        <lazy-plusC/multC-case>
        <lazy-appC-case>
        <lazy-lamC-case>))
```

数很容易：它们已经是值了，所以没必要暂停它们：

```Racket
<lazy-numC-case> ::=

    [numC (n) (numV n)]
```

闭包同样保持不变：

```Racket
<lazy-lamC-case> ::=

    [lamC (a b) (closV a b env)]
```

标识符应该返回它们所绑定的内容：

```Racket
<lazy-idC-case> ::=

    [idC (n) (lookup n env)]
```

算术表达式的参数通常被定义为严格点，不然的话我们会不得不在其他地方实现实际的算术运算：

```Racket
<lazy-plusC/multC-case> ::=

    [plusC (l r) (num+ (strict (interp l env))
                       (strict (interp r env)))]
    [multC (l r) (num* (strict (interp l env))
                       (strict (interp r env)))]
```

最后我们要处理函数调用。在这里，我们不再对参数求值，而是将其暂停。然而，函数位置必须是严格点，否则我们不知道要调用什么函数，也就不知道如何继续计算：

```Racket
<lazy-appC-case> ::=

    [appC (f a) (local ([define f-value (strict (interp f env))])
                  (interp (closV-body f-value)
                            (extend-env (bind (closV-arg f-value)
                                              (suspendV a env))
                                        (closV-env f-value))))]
```

这就行了！添加一种新的答案、插入一些`strict`、并在函数调用参数位置用`suspendV`替换`interp`，我们就将及早调用解释器转换成了惰性调用了。然而，这个小小的变化对我们编写的程序有着巨大的影响！要更全面地了解这种影响，请学习Haskell或Racket中的`#lang lazy`语言。

__练习__
> 如果我们把标识符子句替换为`(strict (lookup n env))`（即对查找标识符的结果调用`strict`），会对语言产生什么影响？请考虑更丰富的语言的情况，比如包含数据结构的情况。

__练习__
> 编写一些程序，它们在惰性求值下会给出和及早求值不同的结果（在两种情况下，同样的程序给出不同的结果）。请给出有意义的差异，一个返回`suspendV`而另一个不不算。比如说，一个会终止而另一个不会，或者一个会产生错误而另一个不会？

__练习__
> 调整两个解释器，让它们记录求得答案的步数。对于在两种求值策略下产生相同答案的程序，一个策略是否总是比另一个需要更多步骤？

### 17.1.5 惰性和赋值

惰性求值的优点之一是它会延迟执行。通常这是好事：它使我们能够构建无限的数据结构，还能避免不必要的计算。不幸的是，它也改变了计算发生的时间，尤其是表达式求值的相对时间，这取决于何时遇到严格点。结果是，程序员基本无法预测计算的顺序。当表达式执行赋值操作时，这显然是个问题，因为现在要预测程序将计算出什么值变得非常困难（相对及早求值来说）。

这导致了，所有惰性语言的核心中都不支持赋值。在Haskell中，赋值和其他状态操作都通过**monad（单子）**和**arrow（箭头）**等多种机制，引入了（严格）序列化代码的能力后再引入；这种顺序性对于能够预测执行顺序以及操作结果至关重要。如果程序结构良好，这些依赖关系的数量应该很小；此外，Haskell类型系统试图在类型本身中反映这些操作，因此程序员可以更轻松地推理其效果。

### 17.1.6 缓存计算结果

既然已经得出结论，惰性计算必须不包含赋值，我们观察到一个令人愉快的结果（能不能称其为副作用呢？）：给定固定的环境，同一表达式总会产生相同的答案。其结果是，当表达式第一次被严格求值时，运行时系统可以缓存其值，并在随后计算它时返回这个缓存值。当然，这种缓存（这是**记忆化**(memoization)的一种形式）只有当表达式每次返回相同的值时才成立，这正是我们所假设的。实际上，编译器和运行时系统可以积极地在程序的不同部分中使用相同的表达式，并且如果其环境的相关部分相同，则合并求值。每当需要被暂停的计算时都求值的策略称为**传名调用**；将结果缓存起来，则称为**传需求调用**。

## 17.2 响应式调用

来考虑这个表达式`(current-seconds)`。求值时，它返回一个数，代表当前时间。例如，

```Racket
> (current-seconds)
1353030630
```

但就算我们盯着这个值，它已经过时了！它表示函数调用发生的时间，而不会不保持当前秒数。

### 17.2.1 动机样例：计时器

假设我们要实现一个计时器，记录经过的时间。理想情况下，我们想这样写：

```Racket
(let ([start (current-seconds)])
  (- (current-seconds)
     start))
```

在JavaScript中就是：

```JavaScript
d = new Date();
start = d.getTime();
current = d.getTime();
elapsed = current - start;
```

在大多数机器上，此Racket表达式，或JavaScript中`elapsed`的值将被求得为`0`，或着某个非常小的数字。这是因为这些程序代表了经过时间的**一次**度量：即第二次调用获取当前时间子程序时的时间。这样我们拿到一个瞬间的时间值，而不是实际的计时器。

在大多数语言中，要构建真正的计时器，我们必须创建某种计时器对象的实例，然后设置回调。每当时钟滴答时，计时器对象——这里代表操作系统——都会调用回调函数。然后回调负责更新系统其余部分的值，祈求这能全局并一致地完成。但是，回调函数无法通过返回值来实现这点，因为它会返回到操作系统，而操作系统无法预知我们的应用程序，也不关心；因此，回调只能通过赋值来执行其行为。例如在JavaScript中：

```JavaScript
var timerID = null;
var elapsedTime = 0;

function doEverySecond() {
  elapsedTime += 1;
  document.getElementById('curTime').innerHTML = elapsedTime; }
function startTimer() {
  timerId = setInterval(doEverySecond, 1000); }
```

假设这里的HTML页面id为`curTime`，并且`onload`或其他回调会调用`startTimer`。

要避免这种意大利面风格的代码，一种替代方案是应用程序反复向操作系统轮询当前时间。然而：

+ 过于频繁地调用会浪费资源，而调用过于不频繁则会导致错误的值。不过，要以恰当的频率进行调用，我们需要先有一个计时器信号！
+ 尽管可以为诸如定时器之类的常规事件创建这样的轮询循环，但对于诸如用户输入等不可预知的行为（其频率通常不能被预测）的来说，这是不可能的。
+ 除此之外，编写这样的循环会污染程序的结构，迫使开发人员承担额外的负担。

然而，基于回调的解决方案展示了**控制的倒置**（inversion of control）。现在，操作系统负责调用（从而进入）应用程序，而不是应用程序调用操作系统（所提供的功能）。理论上响应行为应该在深度嵌套于显示表达式的内部，但它实际上位于顶层，其值会驱动其他计算。这么做的根本原因在于，控制掌握在世界而不是程序手中，所以外部刺激而非内在的程序表达式决定了程序何时运行以及如何运行。

###　17.2.2 回调的类型是四字母单词

这种模式的特征（或者说签名）体现在类型中。由于操作系统对程序的值并不知情，所以回调通常没有返回类型，或者只返回通用的状态指示值，而不是特定于应用程序的值。因此，在静态类型语言中，它们的类型通常是**四个字母的单词**。 例如，下面是Java中某GUI库的片段：

```Java
interface ChangeListener extends EventListener {
  void stateChanged(ChangeEvent e) { ... } }

interface ActionListener extends EventListener {
  void actionPerformed(ActionEvent e) { ... } }

interface MouseListener extends EventListener {
  void mouseClicked(MouseEvent e) { ... }
  void mouseEntered(MouseEvent e) { ... } }
```

OCaml中是这样：

```OCaml
mainLoop : unit -> unit
closeTk : unit -> unit

destroy : 'a Widget.widget -> unit
update : unit -> unit

pack : ... -> 'd Widget.widget list -> unit
grid : ... -> 'b Widget.widget list -> unit
```

在Haskell中，这四个字母中包含一个额外的空格：

```Haskell
select :: Selecting w => Event w (IO ())
mouse :: Reactive w => Event w (EventMouse -> IO ())
keyboard :: Reactive w => Event w (EventKey -> IO ())
resize :: Reactive w => Event w (IO ())
focus :: Reactive w => Event w (Bool -> IO ())
activate :: Reactive w => Event w (Bool -> IO ())
```

诸如此类。在所有这些情况下，类似“void”类型的存在清楚地表明这些函数不会返回任何有意义的值，所以它们唯一的目的必须是修改贮存或者具有其他副作用。这也意味着复杂的组合手段（例如表达式的嵌套）是不可能的：void类型语句唯一的组合操作是顺序执行。因此这些类型表明我们将被迫放弃编写嵌套表达式。

当然，通过我们之前对Web编程的讨论，读者熟知这个问题。由于没有状态，服务器上有这个问题；由于单线程，客户端上也有这个问题。至少在服务器上，我们能够用continuation解决这个问题。但是，不是所有的语言都支持continuation，并且实现continuation也会很繁琐。此外，设置合适的continuation作为回调来传递可能会非常棘手。因此，我们将探索另一种解决方案。

### 17.2.3 替代方案：响应式语言

考虑DrRacket中的FrTime（发音为“Father Time”）语言。【注释】如果我们在交互窗口中运行下面的表达式，我们仍然得到0或者非常小的正数：

```Racket
(let ([start (current-seconds)])
  (- (current-seconds)
     start))
```

> 在DrRacket v5.3中，必须从“语言/Language”菜单中选择该语言；只写`#lang frtime`不会提供想要的交互窗口行为。

事实上，我们可以尝试其他几种表达式，看上去FrTime似乎与传统的Racket完全一样。

但是，它还绑定了额外一些标识符。例如，有一个值绑定到`seconds`。如果我们将其输入交互窗口的提示符，结果非常有意思！首先我们看到`1353030630`，然后一秒后`1353030631`，再一秒`1353030632`，诸如此类。这种值被称为**行为**（behavior）：随时间变化的值。但是我们没有编写任何回调或其他代码将其值保持最新。

行为可以用于计算。 例如可以这么写`(- seconds seconds)`，并且它总是计算为`0`。请在交互提示符中尝试更多表达式：

```Racket
(add1 seconds)
(modulo seconds 10)
(build-list (modulo seconds 10) identity)
(build-list (add1 (modulo seconds 10)) identity)
```

正如你所看到的，行为是“粘性的”：如果任何子表达式是行为，包含它的表达式也是。

基于这里的求值模型，每当`seconds`更新，整个应用程序重新求值：因此，即使我们写了看似简单的表达式，不包含任何明确的循环控制，程序仍然会“循环”。换句话说，最早我们探索的调用语义，其中参数被求值一次，接下来的调用语义中，参数可能被求值零次，现在这个调用语义会根据需要对参数以及与它们对应的整个函数进行多次求值。因此，表达式“内部”的响应式值不再需要被带到“外部”；相反，它们可以嵌套在表达式中，为程序员提供更自然的表达方式。这种评估方式称为**数据流**（dataflow）或**函数响应式**（functional reactive）编程。

> 历史上，**数据流**一般指的是语言具有一阶函数，而**函数响应式**语言支持高阶函数。

FrTime实现了我们所说的**透明响应式**，即程序员可以在程序求值的任意位置插入响应行为，而无需对其上下文进行任何语法修改。这么做的优点是，现有程序中很易于加入响应式，但这也使求值模型更加复杂，程序员估计复杂度也变难了。在其他语言中，程序员需要通过适当的原语明确地引入行为，不那么方便，但可预测性更强。FrTime的姊妹语言Flapjax是JavaScript的扩展，同时支持这两种模式。

> 参见[Flapjax网站](http://www.flapjax-lang.org/)。

### 17.2.4 实现透明响应式

要使现有语言实现透明响应式，我们必须（自然地）改变函数调用的语义。分两步来做。首先将响应式函数调用改写成更复杂的形式，然后我们将展示这种更复杂的形式支持响应式更新。

#### 17.2.4.1 数据流图的构建

使函数调用具有响应性的本质很容易通过去语法糖来解释。假设我们已经定义了新的构造器`behavior`。该构造器的输入为一个thunk，表示每次参数更新时要执行的计算，以及表达式所依赖的所有的值。构造器的返回值存储行为的当前值。那么`(f x y)`这样的表达式就展开为

```Racket
(if (or (behavior? x) (behavior? y))
    (behavior (λ () (f (current-value x) (current-value y))) x y)
    (f x y))
```

其中我们假设，如果输入是常数而非行为，那么`current-value`的行为就是恒等函数。

来看一下使用上述定义的两个例子。考虑两个参数都不是行为的简单情况，例如`(+ 3 4)`。 去语法糖得到

```Racket
(if (or (behavior? 3) (behavior? 4))
    (behavior (λ () (+ (current-value 3) (current-value 4))) 3 4)
    (+ 3 4))
```

由于`3`和`4`都是数而非行为，这就规约为`(+ 3 4)`，正是我们想要的。这反映了一个重要的原则：当没有行为出现时，程序的行为完全等同于与非响应式语言版本。

如果计算`(+ 1 seconds)`，展开为

```Racket
(if (or (behavior? 1) (behavior? seconds))
    (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
    (+ 1 seconds))
```

由于`seconds`是行为，这规约为

```Racket
(behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
```

如果其他表达式依赖于此，现在它们都会看到其参数也是行为，于是该属性如我们之前所论证的那样是“粘性的”。

__练习__
> 上述去语法糖是否依赖于及早求值？如果有的话，是以什么方式？

#### 17.2.4.2 数据流图的更新

当然，仅仅构建行为值是不够的。这里关键的附加信息位于`behavior`的参数中。语言会过滤掉那些本身是行为的参数（例如前述的`seconds`），并将新行为注册为取决于现有行为的行为。这个注册过程创建了行为表达式的依赖关系图，称为**数据流图**(dataflow graph)（因为它反映了数据流动所需的路径）。

如果程序求值得到的不是行为，那么只能是答案，并且这也不会创建图表。但是，如果存在行为依赖，那么求值不会产生传统的答案，而会产生行为值，并且会记录其依赖。（实践中，有必要记录下哪些原始行为实际地被用到，以避免不必要地对程序中没有引用的其他原始行为求值）。总之，**程序执行会生成数据流图**。因此，我们需要的不是新的、专门的语言求值器；而是要将图形构建语义嵌入到传统求值器中。

现在可以运行数据流传播算法了。每当原始行为发生变化时，该算法会调用其存储的thunk，获取新值，存储之，然后发信号给依赖于它的所有行为。例如，如果`seconds`更新，它会通知对应表达式`(+ 1 seconds)`的行为。后者于是对其thunk求值，即`(λ () (+ (current-value 1) (current-value seconds)))`。这会对`seconds`的最新值加`1`，将其作为该行为的的新值——正如我们所期望的那样。

#### 17.2.4.3 求值顺序

上面对图更新的讨论过于简单了。考虑以下程序：

```Racket
(> (add1 seconds)
   seconds)
```

这个程序里有一个原始行为，`seconds`，构造了两个新行为：分别是`(add1 seconds)`和整个表达式。

我们期望这个表达永远计算为真。但是，当`seconds`更新时，取决于处理更新的顺序，可能会在更新`(add1 seconds)`之前更新整个表达式。假设`seconds`的旧值是`100`，所以新值是`101`。但是，`(add1 seconds)`的节点仍然存储了其旧值（因为它尚未更新），所以它的值还是`(add1 100)`即`101`。这意味着`>`会比较`101`与`1`（译注，此处应为`101`），得到假，于是这个表达式返回了其静态描述不可能产生的值。这种情况被称为**毛刺**（glitch）。

避免上面例子所描述的毛刺的方案很简单（而且可以证明这么做足够了）。就是对节点**拓扑排序**。每个节点只在它所依赖的节点更新后才被处理，因此不存在查看过时或不一致的值的危险。

在图中出现循环时问题变得难了。在这种情况下，我们需要特殊的递归算子来为循环行为提供初始值。这样做就打破了循环依赖关系，将求值简化为已定义的过程。

关于数据流语言的求值还有很多可以讨论的内容，例如条件的处理、还有离散和流式（stream-like）行为对偶的概念。 我希望你会去阅读响应式语言的文献，以便更多地了解这些主题。

__练习__
> 之前我们提到过一个Haskell库。不过，公平地说，我们展示的响应式解决方案是用Haskell来阐述的，因为惰性求值更容易支持这种求值形式。
>
> 用惰性求值实现响应式。

## 17.3 